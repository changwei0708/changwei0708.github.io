<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="fz00x0zf&#39;s blog">
<meta property="og:url" content="http://changwei0708.github.io/index.html">
<meta property="og:site_name" content="fz00x0zf&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fz00x0zf&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://changwei0708.github.io/"/>





  <title>fz00x0zf's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fz00x0zf's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-日志">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            日志
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-玩儿">
          <a href="/play/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-play"></i> <br />
            
            玩儿
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2019/11/12/2019/what-is-tech-leadership/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/12/2019/what-is-tech-leadership/" itemprop="url">何为技术领导力</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-12T21:13:02+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/转载/" itemprop="url" rel="index">
                    <span itemprop="name">转载</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自：陈皓专栏-《左耳听风》</p>
<p>以下未正文：</p>
<p>我先说明一下，我们要谈的并不是“如何成为一名管理者”。我想谈的是技术上的领先，技术上的优势，而不是一个职称，一个人事组织者。另外，我不想在理论上泛泛而谈这个事，我想谈得更落地、更实际一些，所以，我需要直面一些问题。</p>
<p>首先，要考虑的问题是——做技术有没有前途？我们在很多场合都能听到：技术做不长，技术无用商业才有用等这样的言论。所以，在谈技术领导力前，我需要直面这个问题，否则，技术领导力就成为一个伪命题了。</p>
<p>技术重要吗？</p>
<p>在中国，程序员把自己称做“码农”，说自己是编程的农民工，干的都是体力活，加班很严重，认为做技术没有什么前途，好多人都拼命地想转管理或是转行。这是中国技术人员的一个现实问题。</p>
<p>与国外相比，似乎中国的程序员在生存上遇到的问题更多。为什么会有这样的问题？我是这么理解的，在中国，需要解决的问题很多，而且人口众多。也就是说，中国目前处于加速发展中，遍地机会，公司可以通过“野蛮开采”来实现自身业务的快速拓展和扩张。而西方发达国家人口少一些，相对成熟一些，竞争比较激烈，所以，更多的是采用“精耕细作”的方式。</p>
<p>此外，中国的基础技术还正在发展中，技术能力不足，所以，目前的状态下，销售、运营、地推等简单快速的业务手段显得更为有效一些，需要比拼的是如何拿到更多的“地”。而西方的“精耕细作”需要比拼的是在同样大小的一块田里，如何才能更快更多地种出“粮食”，这完全就是在拼技术了。</p>
<p>每个民族、国家、公司和个人都有自己的发展过程。而总体上来说，中国公司目前还处于“野蛮开采”阶段，所以，这就是为什么很多公司为了快速扩张，要获得更多的用户和市场 ，需要通过加班、加人、烧钱、并购、广告、运营、销售等这些相对比较“野蛮”的方式发展自己，而导致技术人员在其中跟从和被驱动。这也是为什么很多中国公司要用“狼性”、要用“加班”、要用“打鸡血”来驱动员工完成更多的工作。</p>
<p>但是，这会成为常态吗？中国和中国的公司会这样一直走下去吗？我并不觉得。</p>
<p>这就好像人类的发展史一样。在人类发展的初期，蛮荒民族通过野蛮地掠夺来发展自己的民族更为有效，但我们知道资源是有限的，一旦没有太多可以掠夺的资源，就需要发展“自给自主”的能力，这就是所谓的“发展文明”。所以，我们也能看到，一些比较“文明”的民族在初期搞不过“野蛮”的民族，但是，一旦“文明”发展起来，就可以从质上完全超过“野蛮”民族。</p>
<p>从人类历史的发展规律中，我们可以看到，各民族基本都是通过“野蛮开采”来获得原始积累，然后有一些民族开始通过这些原始积累发展自己的“文明”，从而达到强大，吞并弱小的民族。</p>
<p>所以，对于一个想要发展、想要变强大的民族或公司来说，野蛮开采绝不会是常态，否则，只能赢得一时，长期来说，一定会被那些掌握先进技术的民族或公司所淘汰。</p>
<p>从人类社会的发展过程中来看，基本上可以总结为几个发展阶段。</p>
<p>第一个阶段：野蛮开采。这个阶段的主要特点是资源过多，只需要开采就好了。</p>
<p>第二个阶段：资源整合。在这个阶段，资源已经被不同的人给占有了，但是需要对资源整合优化，提高利用率。这时通过管理手段就能实现。</p>
<p>第三个阶段：精耕细作。这个阶段基本上是对第二阶段的精细化运作，并且通过科学的手段来达到。</p>
<p>第四个阶段：发明创造。 在这个阶段，人们利用已有不足的资源来创造更好的资源，并替代已有的马上要枯竭的资源。这就需要采用高科技来达到了。</p>
<p>这也是为什么像亚马逊、Facebook 这样的公司，最终都会去发展自己的核心技术，提高自己的技术领导力，从早期的业务型公司转变成为技术型公司的原因。那些本来技术很好的公司，比如雅虎、百度，在发展到一定程度时，将自己定位成了一个广告公司，然后开始变味、走下坡路。</p>
<p>同样，谷歌当年举公司之力不做技术做社交也是一个失败的案例。还好拉里·佩奇（Larry Page）看到苗头不对，重新掌权，把产品经理全部移到一边，让工程师重新掌权，于是才有了无人车和 AlphaGo 这样真正能够影响人类未来的惊世之作。</p>
<p>微软在某段时间由一个做电视购物的销售担任 CEO，也出现了技术领导力不足的情况，导致公司走下坡路。苹果公司，在聘任了一个非技术的 CEO 后也几近破产。</p>
<p>尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了。</p>
<p>所以，无论是一个国家，一个公司，还是一个人，在今天这样技术浪潮一浪高过一浪的形势下，拥有技术不是问题，而问题是有没有拥有技术领导力。</p>
<p>说的直白一点，技术领导力就是，你还在用大刀长矛打战的时候，对方已经用上了洋枪大炮；你还在赶马车的时候，对方已经开上了汽车……</p>
<p>什么是技术领导力？</p>
<p>但是，这么说还是很模糊，还是不能清楚地说明什么是技术领导力。我认为，技术领导力不仅仅是呈现出来的技术，而是一种可以获得绝对优势的技术能力。所以，技术领导力也有一些特征，为了说清楚这些特征，先让我们来看一下人类历史上的几次工业革命。</p>
<p>第一次工业革命。第一次工业革命开始于 18 世纪 60 年代，一直持续到 19 世纪 30 年代至 40 年代。在这段时间里，人类生产逐渐转向新的制造过程，出现了以机器取代人力、兽力的趋势，以大规模的工厂生产取代个体工厂手工生产的一场生产与科技革命。由于机器的发明及运用成为了这个时代的标志，因此历史学家称这个时代为机器时代（the Age of Machines）。</p>
<p>这个时期的标志技术是——“蒸汽机”。在瓦特改良蒸汽机之前，生产所需的动力依靠人力、畜力、水力和风力。伴随蒸汽机的发明和改进，工厂不再依河或溪流而建，很多以前依赖人力与手工完成的工作逐渐被机械化生产取代。世界被推向了一个崭新的“蒸汽时代”。</p>
<p>第二次工业革命。第二次工业革命指的是 1870 年至 1914 年期间的工业革命。英国、德国、法国、丹麦和美国以及 1870 年后的日本，在这段时间里，工业得到飞速发展。第二次工业革命紧跟着 18 世纪末的第一次工业革命，并且从英国向西欧和北美蔓延。</p>
<p>第二次工业革命以电力的大规模应用为代表，以电灯、电报以及无线电通信的发明为标志。这些发明把人类推向了“电力”时代。电力和内燃技术的出现，让人类进入了真正的工业时代。随着这些技术的发展，工人阶级开始受到关注，并逐渐出现了有专业知识的中产阶级，而且人数众多。</p>
<p>第三次工业革命。第三次工业革命又名信息技术革命或者数字化革命，指第二次世界大战后，因计算机和电子数据的普及和推广而在各行各业发生的从机械和模拟电路再到数字电路的变革。第三次技术革命使传统工业更加机械化、自动化。它降低了工作成本，彻底改变了整个社会的运作模式，也创造了电脑工业这一高科技产业。</p>
<p>它是人类历史上规模最大、影响最深远的科技革命，至今仍未结束。主要技术是“计算机”。计算机的发明是人类智力发展道路上的里程碑，因为它可以代替人类进行一部分脑力活动。</p>
<p>而且，我们还可以看到，科学技术推动生产力的发展，转化为直接生产力的速度在加快。而科学技术密切结合，相互促进，在各个领域相互渗透。</p>
<p>近代这几百年的人类发展史，从蒸汽机时代，到电力时代，再到信息时代，我们可以看到这样的一些信息。</p>
<p>关键技术。蒸汽机、电、化工、原子能、炼钢、计算机，如果只看这些东西的话，似乎没什么用。但这些核心技术的突破，可以让我们建造很多更牛的工具，而这些工具能让人类干出以前干不出来的事。</p>
<p>自动化。这其中最重要的事就是自动化。三次革命中最重要的事就是用机器来自动化。通信、交通、军事、教育、金融等各个领域都是在拼命地自动化，以提高效率——用更低的成本来完成更多的事。</p>
<p>解放生产力。把人从劳动密集型的工作中解放出来，去做更高层次的知识密集型的工作。说得难听一点，就是取代人类，让人失业。值得注意的是，今天的 AI 在开始取代人类的知识密集型的工作……</p>
<p>因此，我们可以看到的技术领导力是：</p>
<p>尊重技术，追求核心基础技术。</p>
<p>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。</p>
<p>解放生产力，追逐人效的提高。</p>
<p>开发抽象和高质量的可以重用的技术组件。</p>
<p>坚持高于社会主流的技术标准和要求。</p>
<p>如何拥有技术领导力？</p>
<p>前面这些说的比较宏大，并不是所有的人都可以发明或创造这样的核心技术，但这不妨碍我们拥有技术领导力。因为，我认为，这世界的技术有两种，一种是像从马车时代到汽车时代这样的技术，也就是汽车的关键技术——引擎，另一种则是工程方面的技术，而工程技术是如何让汽车更安全更有效率地行驶。对于后者来说，我觉得所有的工程师都有机会。</p>
<p>那么作为一个软件工程师怎样才算是拥有“技术领导力”呢？我个人认为，是有下面的这些特质。</p>
<p>能够发现问题。能够发现现有方案的问题。</p>
<p>能够提供解决问题的思路和方案，并能比较这些方案的优缺点。</p>
<p>能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。</p>
<p>能够用更优雅，更简单，更容易的方式来解决问题。</p>
<p>能够提高代码或软件的扩展性、重用性和可维护性。</p>
<p>能够用正确的方式管理团队。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。</p>
<p>创新能力。能够使用新的方法新的方式解决问题，追逐新的工具和技术。</p>
<p>我们可以看到，要做到这些其实并不容易，尤其，在面对不同问题的时候，这些能力也会因此不同。但是，我们不难发现，在任何一个团队中，大多数人都是在提问题，而只有少数人在回答这些人的问题，或是在提供解决问题的思路和方案。</p>
<p>是的，一句话，总是在提供解决问题的思路和方案的人才是有技术领导力的人。</p>
<p>那么，作为一个软件工程师，我们怎么让自己拥有技术领导力呢？总体来说，是四个方面，具体如下：</p>
<p>扎实的基础技术；</p>
<p>非同一般的学习能力；</p>
<p>坚持做正确的事；</p>
<p>不断提高对自己的要求标准；</p>
<p>好了。今天要聊的内容就是这些，希望你能从中有所收获。而对于如何才能拥有技术领导力，你不妨结合我上面分享的四个点来思考一下，欢迎在留言区给出你的想法，下一篇文章，我也将会和你继续聊这个话题。</p>
<p>以上</p>
<p>（全文完）</p>
<p>转自：陈皓专栏-《左耳听风》<a href="https://time.geekbang.org/column/article/288" target="_blank" rel="noopener">https://time.geekbang.org/column/article/288</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2019/09/29/2019/tech-life/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/29/2019/tech-life/" itemprop="url">技术人员的发展之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-29T20:13:02+08:00">
                2019-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/转载/" itemprop="url" rel="index">
                    <span itemprop="name">转载</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（转载本站文章请注明作者和出处 酷 壳 – CoolShell ，请勿用于任何商业用途）</p>
<p>2012年的时候写过一篇叫《程序算法与人生选择》的文章，我用算法来类比如何做选择，说白了就是怎么去计算，但是并没有讲程序员可以发展的方向有哪些。所以，就算是有这些所谓的方法论，我们可能对自己的发展还是会很纠结和无所事从，尤其是人到了30岁，这种彷徨和迷惑越来越重。虽然我之前也写过一篇《编程年龄和编程技能》的文章，但是还是有很多做技术的人对于自己能否在年纪大时还能去做技术感到没有信心。我猜测，这其中，最大的问题的是，目前从事技术工作的种种负面的经历（比如经常性的加班，被当成棋子或劳动力等等），让人完全看不到希望和前途，尤其是随着年纪越来越大，对未来的越来越没有信心。</p>
<p>同时，也是因为在GIAC的大会被问到，程序员老了怎么办？而在年底这段时间，也和几个朋友在交流中不断地重复谈到个人发展的这个话题。我的人生过半，活到“不惑”的年纪，自然经常性的对什么事都会回头看看总结归纳，所以，在交谈过程中和交谈过后，自己也有一些思考想记录下来。因为我本人也是在这条路上的人，所以，谈不上给他人指导，我同样也是在瞎乱折腾同样每天在思考自己要去哪儿的“一尘世间迷途老生”。况且，我的经历和眼界非常有限，因此，下面的这些关于个人发展的文字和思考必然是受我的眼界和经历所局限的。也欢迎大家补充和指正。</p>
<p>这些东西不一定对，也不一定就是全部，期许可以让你在年底的时候有所思考，在明年的时候有所计划。</p>
<p>一个重要阶段和标志<br>在讲个人发展之前，我需要先说一下人生中的一个非常重要的阶段——20到30岁！</p>
<p>这个阶段的首要任务，就是提升自己学习能力和解决难题的能力。这是一个非常非常关键的时间段！这个时间段几乎决定着你的未来。</p>
<p>30岁以前，这个时间段，应该是人学习和积累的时间段，这个时间段，就是努力学习的时间段。这个时间段，你一定要把时间花在解决问题的技能上。就是说，你一定要练就成的技能是——你能解决大多数人不能解决的问题。使蛮力埋头加班苦干，当一个搬砖老黄牛的是肯定没有前途的。如果你不幸呆在了一个搬砖的地方，天天被业务压得喘不过气来，我建议你宁可让你的项目延期被老板骂，也要把时间挤出来努力学习基础知识，多掌握一些技术（很多技术在思路上是相通的），然后才能有机会改变自己目前的状况。因为，比起你的个人未来，项目延期被老板骂、绩效不好拿不到奖金，都不是什么事儿。</p>
<p>总结一下，你在30岁前，工作5-7年，你需要拥有：</p>
<p>高效的学习能力。这意味着——基础知识扎实、触类旁通、读英文文档不费劲、有寻找前沿知识的能力、能够看到问题和技术的本质、善于思辩、能独立思考。<br>解决问题的能力。这意味着——你要高效的学习能力、见过很多的场景、犯过或是处理很多错误、能够防火而不是救火。<br>如果你拥有这两个能力的现象是—— 在团队或身边的人群中的显现出Leadership。</p>
<p>Leadership并不是当领导和经理，而是一种特征，这种特征有如下两个简单的表象：</p>
<p>帮人解问题。团队或身边中大多数人都在问：“这问题怎么办？”，而总是你能站出来告诉大家这事该怎么办？<br>被人所依赖。团队或身边中大多数人在做比较关键的决定时，都会来找你咨询你的意见和想法。<br>一但你在在30岁之间出现了Leadership这样的特征，那么，你会进入一个正循环的阶段：</p>
<p>因为你学习能力强，所以，你会有更多的机会解决难题。<br>你有更多的机会解决难题，你就会学更多的东西，于是你就会更强。<br>上面这个循环，只要循环上几年，就会让你人生的各种可能性大大的增加。<br>【 注意 】</p>
<p>要达到这样的特质，需要找到自己的长处、以及适合自己的环境。就像鱼的特长是呆在水里，让鱼儿去追求陆上动物的刺激生活并不靠谱。<br>一般说来，有这样的潜质的人，在学校中就应该要出现。如果你在大学中还没有出现这样的潜质，那么，你在工作当中要加倍努力了（注：所谓的加倍努力，不是让你使蛮力加班，而是让你多学习成长，使蛮力拼命是弥补不了能力、思维、眼界上的缺陷的）。<br>Leadership也有范围的，比如，身边的朋友，工作中的团队/部分，圈内，整个行业。Leadership的范围越大，你的个人发展的选择性就越高。反之则越小。<br>如果已到了30岁左右，还是没有出现这样的特征。那么，可能未来你也很难有这样的Leadership了。而你的个人发展的可能性可能也就不多了（sigh…）<br>读到这里，我必需要说一下，如果你已开始显现出你的Leadership，那么你才谈得上个人发展，这篇文章后续的内容也可能才会对你有意义。</p>
<p>个人发展的三个方向<br>以我个人短浅的经历和视野，目前只看到的人的发展有如下三个大方向（他们之间可能会有重叠）：</p>
<p>1）在职场中打拼</p>
<p>2）去经历有意义有价值的事</p>
<p>3）追求一种自由的生活</p>
<p>这三个方向，我个人或多或少都体验过，我也见过身边的很多人走这三个方向走的比较成功。也许还有别的方向，没办法，现在，我的视野就这么大，所以，我在这里，我主要就是谈谈这三个方向。Again，人有资格去走这三个方向的前提是——已有了上面我说的Leadership那种特质！</p>
<p>一、在职场中发展<br>在职场中发展应该是绝大多数人的选择。通过加入公司来达到人生的发展。</p>
<p>我们经常可以看到很多所谓的“职业规划”，但是大多数职业规划只不过人力资源搞出来的东西，和实际其实是有很大出入的。我的人生经历中，有18年左右是在公司中度过的，在过银行，小公司，大公司，民营公司，外国公司，传统IT公司，互联网公司，不同的公司完全有不同的玩法和文化，我的经历还算丰富，但也不算特别成功，这里只分享一些我在职场中的心得（不一定对，仅供参考）。</p>
<p>1、去顶尖公司</p>
<p>去顶尖公司的一个目的就是让你的Leadership的范围的可能性扩大。</p>
<p>因为公司和公司的差距也不小，所以，就算你在低端公司里是骨干份子，但在高端公司里可能只是一个普通员工（就像中国足球队的主力到了英超可能都无法入选）。所以，在职场中，如果你要让你的个人价值最大化的话，你一定要去顶尖的公司。因为顶尖公司里有非常不错的工作方法和场景，这并不是能看书或是交流得来的，这是必需要去亲身体验的。所以说，在顶尖公司掌握的技能，开阔的眼界，通常来说都会比低端公司的要多得多。</p>
<p>另外，每个公司的工作级别都是有相互对标的，比如：阿里的P几对应于百度的T几。国内的一线公司职位还相当，但是如果和国外一线公司的比，那就有差距了，而且差距还很大。比如，Google或Facebook的某个高级工程师，可能就对应于阿里的P8/P9甚至更高。</p>
<p>是的，对于职场来说，如果你在顶尖公司是骨干，那么，你去低端公司，则有很大机会会成为他们高管和核心。就好像你在Facebook里干三五年成为他们的技术骨干，那么你到BAT去成成为高管概率是非常大的。反过来，如果你毕业主去了BAT成为了一个螺丝钉，在天天加班中度过你的青春，你干个十年能成为BAT的高管的概率可能会非常的低。</p>
<p>2、去真正的创业公司</p>
<p>去顶尖公司和去创业公司在某些时候并不冲突。不过，这里我想讲的是，一个技术能力强的人在大公司可能会被埋没掉。因为大公司业务成功后，</p>
<p>成功的公司在招聘各种高级技术人才都不会成为问题，于是少你一个不少，多你一个不多。<br>成功的公司其整个技术体系已经完成，Legacy的问题也比较多，所以，可以供你发挥的余地不大。<br>成功的公司更多的可能会想要稳定的系统，稳定必然会产生保守，而保守则产生不思进取。<br>所以，对于中高级人才来说，在大公司里的能产生的个人价值，可能远远不如那些求贤若渴、没有包袱、可以尽情施展、相对更为灵活和自由的创业型公司。</p>
<p>不过，去创业公司需要小心仔细的挑选和评估，创业公司的不确定因素很多，也和创始人的因素太大了，所以，你需要小心了解创始人和他们的业务情况，想法和理念差不多才能更好的共事。</p>
<p>好多创业公司其实并不是真正的创业公司，他们创业有很大的侥幸和驱利心理，要小心甄别。因为那不是真正的创业公司。</p>
<p>3、职业生涯的发展阶段</p>
<p>首先，有一个不争事实——整个社会是会把最重要的工作交给30岁左右的这群人的。也就是说，30岁左右这群人是这个社会的做事的中坚力量。</p>
<p>所以，这是一个机遇！如果你有了Leadership，你就一定能在这个时间段内赶得上这个机遇——公司和领导对你寄于信任和厚望，并把重要的团队和工作交给你。</p>
<p>于是，你的30岁到40岁就成了一个职业生涯的发展期，也就是你的事业上升期。如果你到40岁都没有赶上，那么你的职业生涯也就这样了，老有所成的人是少数。</p>
<p>在你事业的上升期，你需要更多的软技能，比如：</p>
<p>带领产品和业务的发展的能力<br>推行自己喜欢的文化的能力<br>项目管理的能力——在任务重、时间紧中求全<br>沟通和说服别人的能力<br>解决冲突的能力<br>管理和发展团队的能力<br>解决突发事件的应急能力<br>…… ……<br>另外，你还要明白在职场里的几个冷酷的事实：</p>
<p>你开始要关心并处理复杂的人事。尤其在大公司，大量的人都是屁股决定脑袋，利益关系复杂，目标不一致，每个人心里都有不一样的想法。这个时候再也不是talk is cheap, show me the code！而是，code is cheap，talk is the matter。你需要花大量的时间去思考和观察形形色色的人。需要耗费大量的精力在不同的人之间周旋，而不是花时间去创造些什么有价值的东西。<br>你要开始学会使用各种政治手段。办公室政治不可避免，越大的公司越重，自从你开始成为一线的leader的那一天起，你就开始成为“里外不是人”的角色，需要在下属和领导，员工和公司之间周旋。随而你的级别越来越高，你需要使用更多的政治手段，你会学会审时度世的站队，学会迎合员工和领导，学会用官员的语言说话，学会此一时彼一时，学会妥协和交换，学会忍气吞声，学会在在适当的时机表现自己，学会波澜不惊，学会把自己隐藏起来，甚至你还会迷失自我，开始学会一些厚黑学，比如不得不在适当的时机在背后捅人刀子……你可能会成为一个你自己都讨厌的人<br>听上去真的好无聊，所以，你现在也明白为什么高层们都看上去很忙很累，而且抽不出时间来关心细节问题，因为，他们更多的是要协调整个组织和系统来运转，甚至还要四处周旋，各种博弈，没办法，这是职场的必需的东西！听起来是不是感觉人类很愚蠢？这真是没办法的事。如果你不想或是也没有能力玩这些东西，那么你需要去那些可以让技术人员安安心心做技术的公司。这类的公司，我见过Microsoft、Google、Amazon或是一些创业公司里都有。国内的大公司中也有让技术人员成长的职业成长线，但老实说，表面上看似是一个让人专心做技术的升职成长线，但其实还是管理岗位。</p>
<p>所以，技术人员在职场中的归宿有两条路 —— 到真正的技术公司成为一个专心做技术的人，或是在成为一个职业的经理人。</p>
<p>二、追求人生的经历<br>先说三个故事，</p>
<p>第一个，是在阿里的时候，有一天在内网里看到一个贴子，一个做产品的女孩说自己准备离职要去法国学烘培厨艺，引得大家热评。<br>第二个，是在亚马逊的美国老板，他每年都要去报个培训班学一个技能，比如：厨艺、开双翼飞机、夜总会里的DJ……、甚至去华盛顿去学当一个政客。<br>第三个，是在汤森路透工作时，一个英国的同事，有一天他说他离职了，和自己的老婆准备用余生去周游世界，我问他是不是有足够多的钱了？他和我说，钱不够，他俩口子的计划是，边旅游边打工，打工打够到下一站的钱就走。他还说，那种用假期去另一个城市的旅游太没意思了，如果你不在那个地方生活上一段时间 ，你怎么能算是好的旅游体验呢？好吧，无法反驳。<br>我是觉得他们把自己的人生过得如此有意思，令我很佩服。虽然跨界跨得有点猛，但是 Why Not？</p>
<p>在这里，我想说，去追求一种和众人不一样的人生经历也是一件挺好的事，我个人感觉，比起在职场里有趣地多多了。如果你厌倦了职场，其实为什么不去追求一下不同的人生经历呢。就算你不想去追求跨度比较大的人生经历，那么，在技术圈里，也有很多有价值有意思的经历也可以去的。追求刺激有意义的与众不同的经历的人，其实也能算是一种人生的成功，不是吗？</p>
<p>如果只说技术方面，我个人看到的去追求经历的人，有两种追求的人其实也很成功的：</p>
<p>到技术创新的发源地去经历创新。计算机互联网各种技术的创新引擎，基本上来说，就是在美国了。我们赶上了这个时代，也选对了这个时代最火热的行业，那么，有什么理由不去这个时代的技术发动机那里去经历呢？在美国硅谷湾区，无论是大公司，还是创业公司，都在迸发着各式各样的创新，如果有能力有机会，为什么不努力去经历一下呢？不经历一下，老了不会觉得错过了是一种后悔吗？<br>去经历下一个热点技术的发展。从IT，到互联网、再到移动互联网、云计算、大数据，再到未来的AI，VR，IoT……，技术创新的浪潮一波接一波的过来，你是想在那继续搬砖搬下去，是想迎浪而上去经历浪潮，还是想成为一个随波逐流的人？<br>打工也好，创业也好，在国内也好，在国外也好，这些都是形式，不是内容。内容则是你有没有和有想法的人去经历有意义有价值事？人生苦短，白驹过隙，我们技术人员最大的幸运就是生在这样一个刺激的时代，那么，你还有什么理由不去追逐这些前沿刺激的经历呢？</p>
<p>三、追求自由的生活<br>我相信“自由”这个事，是所有人的心中都会想去追求的。“生命诚可贵，爱情价更高，…… ”（哈哈）</p>
<p>但一说起自由，绝大多数人都想到的是“财富自由”或是“财务自由”，其实，并不完全是这样的，在自由的通路上，我个人的经历告诉我，其实，你会有很多的不同类型的自由。下面，是我对几个层次的“自由”的理解。</p>
<p>第一层自由——工作自由。人的第一层自由的境界是——“工作自由”，我到不是说你在工作单位上可以很自由，虽然有特例，但并不普遍。我想说的“工作自由”是——你不会有失业危机感了。也就是说，你成了各个公司的抢手货，你不但不愁找不到工作，而且你是完全不愁找不到好工作。试想一下，如果是工作来找你，一方面，你就有真正意义上的工作选择权了，另一方面，你都不愁工作了，你完全就可以随时离职去干你想干的事了。此时，你就达到了“工作自由”。</p>
<p>第二层自由——技能自由。工作自由已是不错，不过前提是你还是需要依赖于别人提供的工作机会。而技能自由则是你可以用自己的技能养活自己，而不需要去公司里工作。也就是所谓的自由职业者了，社会上，这样的人也不少，比如，一些健身体育教练、设计师、翻译者、作者……这些都可以算是自由职业者，程序员这个职业中只要不是搬砖的，有想法的，就有可以成为自由积业者的潜质，想一想，你拥有的编程能力，其实是一种创造的能力，也就是创造力，只要你Make Something People Want（YC创业公司的slogan），你是完全可以通过自己的技能来养活自己的。如果你通过某些自动化的东西，或是你在App上做了一个软件个体户，让自己的收入不断，甚至你做了一个开源软件，社区每个月都给你捐款捐到比你打工挣的还多，那么你就真正的有了技能自由了。</p>
<p>第三层自由——物质自由。我把财务自由换了一种说法。我个人觉得，除了有个好爸爸之外这种特例的情况，如果你想有物质自由的话，本质上来说，你一定要学会投资，投资不一定是你的钱，时间也是一种财富，年轻更是，你怎么投资你的时间还有你的青春？你要把你的投资投到什么样的事，什么样的人？对于投资这个事，风险也比较大。但是，人生不敢冒险可能才是最大的冒险。这个世界有很多技术不是你能看书学来的，而要只能在实战中学会的，比如：游泳。投资可能也是一种。只有真正懂投资的人，或是运气非常好的人，才可能实现物质自由。</p>
<p>追求自由的生活，其实也是个人发展道路上的一个不错的选择。通常来说，自由的人，能力都不差，钱也不会少。因为，他们懂得投资。</p>
<p>也就是说，拥有追求自由能力的的人，</p>
<p>不但有领导力和创造力（也可指导大多数人并走在大多数人前面）<br>同时他还懂得怎么投资（知道时间和精力和金钱应该投在什么地方）<br>（注：这里我没有提精神自由，老实说，精神上的自由我也不清楚是什么东西，因为我还没有见过，眼界有限，所以先按不表了，不然真成鸡汤文了）</p>
<p>总结<br>无论是在职场中打拼，还是追求精彩的经历，还是去实现自由，我觉得都是不错的个人发展的方向。</p>
<p>他们都有重叠，比如：</p>
<p>你可以在职场中去追求那些刺激的经历的公司。<br>同样也可以通过加入有潜力高速发展的公司来达到自由。<br>你也可以通过追寻不一样的经历来达到人生的自由。<br>……<br>总之，这里的逻辑是——</p>
<p>能够去规划自己的个人发展的人，通常都是有很多机会和可能性的人。<br>有很多机会和可能性的人，通常都是有Leadership，喜欢冒险的人。<br>有Leadership喜欢冒险的人，通常都是学习能力强，思维活跃，喜欢折腾，懂得“投资”的人。<br>学习能力强思维活跃的人，通常来说，都是喜欢看书，喜欢实践和新鲜事物，不怕艰难和挑战，用智力而不是使蛮力的人。<br>懂得“投资”的人，通常来说，他们更多的关注的是未来和长远的成长，而不是当下的KPI、奖金和晋升。<br>（全文完）</p>
<p>（转载本站文章请注明作者和出处 酷 壳 – CoolShell ，请勿用于任何商业用途）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2019/07/10/2019/what-is-io-multiplexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/2019/what-is-io-multiplexing/" itemprop="url">什么是 I/O 多路复用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-10T21:13:48+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/I-O/" itemprop="url" rel="index">
                    <span itemprop="name">I/O</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在高并发环境下，web 服务器需要处理成千上万的客户端连接，如何最大限度发挥单台机器的性能，使之在处理大量连接时仍保持较低的负载，这是个很重要的课题。本文介绍下解决此类问题的一种很经典的方式：I/O 多路复用。<br>传统 I/O</p>
<p>为了了解 I/O 多路复用是怎么产生的，我们先看下传统的网络 I/O 模式，也被称为 BIO(Blocking IO)。<br>在编写服务端网络程序时，传统的方式是这样的：创建套接字并绑定端口，然后用一个 while 循环，在循环里调用 accept，程序会阻塞，一旦有连接到来，accept 就返回，然后针对该连接做相应的读写处理。形式像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建套接字</span><br><span class="line">ServerSocket serverSocket = new ServerSocket();</span><br><span class="line">// 绑定套接字</span><br><span class="line">serverSocket.bind(new InetSocketAddress(2345));</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">while(true) &#123;</span><br><span class="line">    // 调用 accept 等待客户端连接，程序阻塞，当有连接到达时才返回</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    // 对套接字读写</span><br><span class="line">    handle(socket);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">// 关闭套接字</span><br><span class="line">serverSocket.colse();</span><br></pre></td></tr></table></figure>
<p>一般我们在刚学网络编程时，都会用这种的方式，也被称为单线程模式，这种模式的特点就是简单直白，方式固定，写起来较容易。但有个致命问题：同一时间，它只能处理一个客户端请求，因为它直接是在主线程中处理请求的，只有在上一个请求处理完毕，才能接着处理下一个请求，一旦某个请求处理较慢，那后面的请求只能等待。<br>把上面的单线程模式改下，对每个连接，新开一个线程单独进行读写处理，这样就可以同时处理多个连接了，形式如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建和绑定步骤不变</span><br><span class="line">   // ...</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">       Socket socket = serverSocket.accept();</span><br><span class="line">       // 新开一个线程，对套接字读写</span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           handle(socket);</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这种模式就是多线程模式，比上面的那种要高级一点，它可以同时处理多个连接，因为对每个连接的处理都是在一个单独的线程中，和主线程分离开来，主线程可以继续 accept 客户端连接。<br>但这种模式仍然存在问题：<br>线程的创建和销毁的成本是很高的，创建线程需要消耗内存，1 个线程需要耗费 512K 到 1M 的内存，几十上百个可能看不出来，成千上万的话，内存很快就耗尽。<br>线程池能解决部分问题，但当请求过多，线程池仍然处理不过来，导致大量的请求超时，更严重的是，大量的线程会导致大量的线程切换，线程切换，或者说上下文切换是需要 CPU 开销的，线程切换越频繁，真正分配给业务的 CPU 资源就越少。<br>上面的两种模式，不管是单线程模式还是多线程模式，我们都称之为阻塞模式(Blocking I/O)，是因为它们对连接的处理，都是以线程为基石，在一个线程中处理一个 socket 的读写，但实际情况是，线程的大部分时间都是在等待数据的到来。当调用 recvfrom 时，线程会等待着客户端的数据到达网卡，然后网卡把数据交给内核，然后内核再把数据拷贝到用户进程空间，这时 recvfrom 才会返回。这个过程<br>中，线程的绝大部分时间都是处于等待数据状态，什么也做不了。而下面要介绍的 I/O 多路复用，就是为解决此问题而生。<br>I/O 多路复用</p>
<p>上面我们分析了由线程直接处理网络 I/O 的低效原因，想象下，当我们调用 recvfrom，发现数据还没准备好，就不傻等了，而是告诉系统：等数据准备好了，你告诉我下，我再来读。这时线程可以先去干点别的，比如去检查下有没有其他的连接。过了一会儿，系统产生了一个可读事件，告诉我们，你要的数据准备好了，可以来读了，这时就可以继续回到刚才的地方读取数据。这样效率不是就好多了吗？因为在等数据的同时，我还可以干其他的事情。这是一种非阻塞模式，那么这种“数据好了通知我们”的机制怎么实现呢？<br>其实，操作系统已经给我们提供了 select，poll，epoll，kqueue 这样的系统调用，来完成我们上面的要求，这些系统调主要干一件事：监听一个或多个文件描述符上的各类事件，一旦文件描述符上有事件产生，就返回。文件描述符，是 Unix 系统下的一个叫法，也称为 fd(file descriptor)，下文统称为 fd，fd 对应于 Windows 平台下的句柄（handle），一个文件描述符唯一标识了某进程打开的某个文件，Unix 的设计哲学就是一切皆文件，socket 也是文件，可以作为 fd 被监听。监听哪些事件呢？有：连接事件（acceptable），可读事件（readable），可写事件（writeable），关闭事件（closeable）等。于是通过这类系统调用，监听多个 fd，一旦某个 fd 上有某个事件产生，调用就会返回，于是我们知道“有事发生”，然后根据事件的类型，做不同的处理。因此，有时也把这种模型称为事件驱动模型，或者 Reactor 模式。<br>I/O 多路复用的关键，是它可以让内核监听 fd 的事件，而且可以同时监听多个 fd，和用一个线程处理一个 socket 连接有根本的区别，它只需要一个线程或进程，就管理了多个连接，我们可以用一句话来概括 I/O 多路复用：在一个线程或一个进程中，监听了多个 fd。这里的复用，指的是多个 fd，或者说多个连接，复用了一个线程或者进程。<br>I/O 多路复用的三种方式</p>
<p>select</p>
<p>首先来看 select，它的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>nfds 为需要监听的最大 fd 个数+1。<br>中间的三个参数 readfds、writefds 和 exceptfds 指定我们要让内核监听读、写和异常条件的 fd。如果对某一个的条件不感兴趣，就可以把它设为空指针。fd_set 结构体可以理解为集合，存放的是 fd，可以通过下面的宏处理这三种 fd_set:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_CLR(inr fd, fd_set *fdset);   // 清除 fd set 中相关 fd 的位</span><br><span class="line">FD_ISSET(int fd, fd_set *fdset); // 测试 fd set 中相关 fd 的位是否为真</span><br><span class="line">FD_SET(int fd, fd_set *fdset);  //  设置 fd set 中相关 fd 的位</span><br><span class="line">FD_ZERO(fd_set *fdset);         //  清除 fd set 的全部位</span><br></pre></td></tr></table></figure>
<p>select 的使用方法，我们看下面的例子，为了简单起见，我们只传入了可读事件的 fd，对其他的字段设置为 NULL，表示我们不感兴趣。在 for 事件循环中，调用 select，一旦 fd 有可读事件，就调用 read 处理读事件。其中判断可读是通过调用 FD_ISSET 来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ssize_t nbytes;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">    /* select call happens here */</span><br><span class="line">    if (select(FD_SETSIZE, &amp;read_fds, NULL, NULL, NULL) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;select&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">        if (FD_ISSET(i, &amp;read_fds)) &#123;</span><br><span class="line">            /* read call happens here */</span><br><span class="line">            if ((nbytes = read(i, buf, sizeof(buf))) &gt;= 0) &#123;</span><br><span class="line">                handle_read(nbytes, buf);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* real version needs to handle EINTR correctly */</span><br><span class="line">                perror(&quot;read&quot;);</span><br><span class="line">                exit(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，程序会阻塞在 select，一旦 fds 中有可读事件，select 即返回，然后就可以遍历，查看到底是那个 fd 可读，并做相应处理。<br>I/O 多路复用概念被提出来后，select 是第一个实现它的系统调用，它是一个古老的实现，在 20 世纪 80 年代就诞生了，几乎所有的平台上都支持，良好跨平台支持也是它的一个优点。然而，它的缺点也不可忽视：<br>监听的 fd 数量存在最大限制，在 Linux 上这个最大值是 1024，这在 select 诞生的那个年代来说足够了，但对现在互联网信息爆炸时代来说，极大限制了 select 的可用性。<br>其次，一旦监听的 fd 上有事件产生，select 仅仅会返回，但并不会告诉我们是哪些 fd 产生了事件，这时需要自己遍历所有的 fdset，依次检查每个 fd 上的事件标志位。显然，遍历的这个过程时间复杂度是 O(n)。因此，即使把上面的最大监听数改大，但带来的问题是效率的降低。<br>poll</p>
<p>再来看 poll，它是 select 的改进版，主要改进点有：<br>去掉了 1024 这个最大监听数的限制。用户可以自定义监听 fd 数。<br>简化了 select 调用方式，它的原型如下：<br>1<br>int poll (struct pollfd *fds, unsigned int nfds, int timeout);<br>不同于 select 使用三个位图来表示三个 fdset 的方式，poll 使用一个 pollfd 的指针实现，pollfd 结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct pollfd &#123;</span><br><span class="line">        int fd;                         // file descriptor</span><br><span class="line">        short events;                   // requested events to watch</span><br><span class="line">        short revents;                  // returned events witnessed</span><br><span class="line">&#125; pollfd_t;</span><br></pre></td></tr></table></figure>
<p>pollfd 结构包含了要监听的 event 和发生的 event，不再使用 select “参数-值”传递的方式，使得 poll 支持的 fd 集合限制远大于 select 的 1024。但是，poll 并没有解决 select 最根本的问题：它依然需要遍历所有 fd 来检查事件，遍历的时间复杂度依然是 O(n)。<br>epoll</p>
<p>再来看看 epoll，epoll 和上面的 select 和 poll 有着本质的区别，除了没有最大监听数限制外，它还有一个最大特点：只返回有事件发生的 fd，所以不需要遍历所有监听的 fd 来找到哪些 fd 产生了事件。因此，它的时间复杂度为 O(k)，其中 k 为产生事件的 fd 数。因此，epoll 的效率不会像 select 和 poll 那样，随着监听 fd 的数量的增长而下降，那么它是怎么做的呢？来看下使用 epoll 时需要的三个系统调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</span><br></pre></td></tr></table></figure>
<p>epoll_create：创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 select 中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>epoll_ctl：对指定 fd 执行 op 操作，epfd 是 epoll_create 的返回值。op 表示操作，用三个宏来表示：添加 EPOLL_CTL_ADD，删除 EPOLL_CTL_DEL，修改 EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件，epoll_event 告诉内核需要监听什么事。<br>epoll_wait：等待 epfd 上的 io 事件，最多返回 maxevents 个事件。<br>上面对函数的解释可能比较抽象，简单来讲：当我们调用 epoll_create 时，内核就创建了一棵红黑树和一个就绪（Ready）链表，其中，红黑数用于存储后面 epoll_ctl 传过来的 fd，以支持高效的查找、插入和删除。就绪链表用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个就绪链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。使用 epoll 的方式大概长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define MAX_EVENTS 10;</span><br><span class="line">int event_count;</span><br><span class="line">// 这里是创建网络程序的一般步骤</span><br><span class="line">// ... socket(), bind(), listen()</span><br><span class="line"></span><br><span class="line">// 创建epoll文件描述符，出错返回 -1</span><br><span class="line">// int epoll_create(int size) 从Linux2.6.8开始，size 值被忽略，不过为保持兼容需要设定为一个正整数</span><br><span class="line">int epollfd = epoll_create(1024);</span><br><span class="line">struct epoll_event ev, events_in[MAX_EVENTS]; // 记录套接字相关信息</span><br><span class="line">ev.events = EPOLLIN; // 监视有数据可读事件</span><br><span class="line">ev.data.fd = fd; // 文件描述符数据，其实这里可以放任何数据。</span><br><span class="line"></span><br><span class="line">// 加入监听列表，当fd上有对应事件产生时，epoll_wait会将epoll_event填充到events_in数组里</span><br><span class="line">// 出错返回 -1</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line"></span><br><span class="line">while(1) &#123;</span><br><span class="line">    // 等待事件，epoll_wait 会将事件填充至 events_in 内</span><br><span class="line">    // 返回获得的事件数量，若超时且没有任何事件返回0，出错返回 -1。timeout 设置为 -1 表示无限等待。</span><br><span class="line">    int event_count = epoll_wait(epollfd, events_in, MAX_EVENTS, -1);</span><br><span class="line">    for (int i = 0; i&lt;event_count; i++) &#123; // 遍历所有事件</span><br><span class="line">        if (events_in[i].data.fd == fd) &#123; // 新连接请求</span><br><span class="line">            int new_fd = accept(fd, NULL, NULL);</span><br><span class="line">            ev.events = EPOLLIN;</span><br><span class="line">            setnonblocking(new_fd);  // 如果要使用Edge Trigger还需将 new_fd 设为非阻塞</span><br><span class="line">            ev.data.fd = new_fd;</span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;ev); // 将新连接加入监视列表</span><br><span class="line">        &#125; else &#123;  // 其他的事件处理，如读写事件</span><br><span class="line">            int new_fd = events_in[i].data.fd;</span><br><span class="line">            // ... handle(new_fd);</span><br><span class="line">            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, NULL); // 不再监听fd，最后一个参数被忽略</span><br><span class="line">            close(new_fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>epoll 有两种工作模式：LT（level trigger）模式和 ET（edge trigger）模式，也叫水平触发和边沿触发，默认的是 LT 模式<br>LT 模式：当 epoll_wait 检测到 fd 事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。<br>ET 模式：当 epoll_wait 检测到 fd 事件发生，只有当 fd 事件变化时，即从 unreadable 变为 readable 或从 unwritable 变为 writable 时，它才返回事件 fd，因此应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此 fd 事件。<br>一句话：如果 fd 上有事件发生，LT 模式下会一直通知你，ET 模式只会通知一次。<br>因此，如果 epoll 工作在 ET 模式，正确的读写方式应该如下所述，具体描述可以参考这篇文章，这里只说结论：<br>读：只要可读，就一直读，直到返回 0，或者 errno = EAGAIN<br>写：只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN<br>ET 模式也称为高速模式，在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接字模式，以避免由于一个 fd 的阻塞读/阻塞写操作把处理多个 fd 的任务饿死，如上面代码的第 25 行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnonblocking(new_fd);</span><br></pre></td></tr></table></figure>
<p>epoll 的上述特点，使 I/O 多路复用系统的性能提升到一个新的台阶。当管理的连接数不多时，使用 select/poll 和使用 epoll 的差别不大，但是当连接数上十万百万时，就会发现 epoll 的效率远高于 select/poll。因为在互联网大量并发的连接场景下，实际同一时刻，真正活跃（Active）的连接，其实只占少数，其他的都是空闲（idle）状态。epoll 不遍历所有连接，只对活跃的连接做处理。<br>需要注意的是：epoll 是 Linux 2.6 内核版本引入，只用于 Linux 平台，BSD 或 MacOS 对应的实现就是 kqueue，Windows 下就是 IOCP。<br>怎么使用</p>
<p>实际上，当我们使用 I/O 多路复用时，也很少会直接调用 select/poll/epoll，这样开发周期长，对开发者有较高要求，出问题难以调试，直接使用现有的库会大大降低开发难度，如 libevent，netty 等，他们对于不同的平台底层使用不同的方式，比如你是 MacOS，底层就用 kqueue，如果是 Linux 2.6或更新，则用 epoll。这些库提供了一套统一的 API，好处是允许你的代码在不同平台上运行而不需要改变任何代码，用户只需直接使用即可。<br>I/O 多路复用的问题</p>
<p>细心的同学会发现，I/O 多路复用是单线程的，不能充分利用多核；同时，单线程模型事件处理中，不能有阻塞，一旦发生阻塞，会大大降低该模型性能，甚至不如多线程模型的 BIO ，这就对开发者的技术有更高的要求了。<br>另一方面，基于事件驱动的 I/O 多路复用，仍然属于阻塞型 I/O，它会阻塞在等待事件发生的系统调用。<br>I/O 多路复用案例</p>
<p>I/O 多路复用技术，已经在很多高性能软件和系统中得到广泛使用，只要弄明白了 I/O 多路复用的底层原理，也就明白那些优秀的软件为何性能很高了。经典的如 Redis，我们知道 Redis 是一个高性能的缓存服务器，它是单线程的，但它的性能并没有因为单线程而降低，反而特别高效，其中一个很重要的原因就是使用的 I/O 多路复用。在 Redis 内部，将客户端的套接字以文件事件进行抽象，客户端的连接，读写等操作，均会在 Redis 产生相应的文件事件，然后由相应的事件处理器进行处理，而 Redis 的单线程，可以监听成千上万个套接字，从而保证了高效的网络通信。同时，Redis 有良好的跨平台特性，由此我们可以断定，Redis 底层并没有写死使用 epoll 方式，因为那样会限制它只能运行于 Linux 平台，实际上，在我们编译 Redis 时，Redis 会根据平台情况，选择使用最合适的方式。<br>再如 Nginx，Nginx 是一款优秀的，抗并发能力很强的 web 服务器，在它的 Worker 进程中，也是通过 kqueue、epoll 等事件通知机制循环处理连接请求，可以使 Nginx 在高并发的情况下，仍然保持较低的 CPU 使用率，同时它也有良好的跨平台特性。nginx 的架构模型可以参考这篇文章<br>再如 Netty，Netty 是 Java 写的高性能网络编程框架，它是 Java NIO 库的进一步封装，大大简化了 NIO 的使用方式，Netty 的网络部分使用了经典的 Reactor 模式，其中的 IO 线程 NioEventLoop 聚合了多路复用器，称为 Selector，根据平台选择不同的 I/O 多路复用，如 kqueue、epoll。同时，它可以搭配线程池使用，每个线程都是一个 Selector，成为多线程的 Reactor 模型。因此它的性能也非常强劲。Netty 的线程模型可以看这篇文章</p>
<p>总结</p>
<p>上面，我们讨论了传统的 BIO 模式的弊端，以及 I/O 多路复用的原理和经典使用案例，那么我们以后写网络程序，是不是无脑用 I/O 多路复用呢？得看场景：<br>如果你的应用并发量不大，用户的请求连接少，连接不是瓶颈，那么请直接使用 BIO+多线程方式，简单易调试，完全用不着 I/O 多路复用，这样只会增加代码的复杂度，出问题难以调试。<br>如果你的应用并发量高，需要同时处理海量的连接，那么请使用 I/O 多路复用方式。但是记住，你必须始终保持异步思想，事件处理中不要有任何阻塞操作。至于是用 select/poll 还是 epoll，请看这篇文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参考</span><br><span class="line">https://segmentfault.com/a/1190000003063859</span><br><span class="line">https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</span><br><span class="line">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</span><br><span class="line">https://www.zhihu.com/question/20122137</span><br><span class="line">http://kimi.it/515.html</span><br><span class="line">https://segmentfault.com/a/1190000016875057</span><br></pre></td></tr></table></figure></p>
<p>本文由 JimmyXu 发表，采用署名-非商业性使用-禁止演绎4.0进行许可<br>非商业转载请注明作者及出处，商业转载请联系作者本人<br>本文标题: 什么是 I/O 多路复用<br>本文链接: <a href="http://xujimmy.com/2019/06/27/what-is-io-multiplexing.html" target="_blank" rel="noopener">http://xujimmy.com/2019/06/27/what-is-io-multiplexing.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2018/01/21/2018/linux-elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/2018/linux-elasticsearch/" itemprop="url">Linux环境部署Elasticsearch 6.x和常见问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-21T21:13:02+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES/" itemprop="url" rel="index">
                    <span itemprop="name">ES</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Elasticsearch（ES）是一个基于Lucene构建的开源、分布式、RESTful接口的全文搜索引擎。 Elasticsearch还是一个分布式文档数据库，其中每个字段均可被索引，而且每个字段的数据均可被搜索，ES能够横向扩展至数以百计的服务器存储以及处理PB级的数据。</p>
<p>本文内容基于Elastic 技术栈6.x版本；</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># lasticsearch-6-3-2</span><br><span class="line"></span><br><span class="line">wget https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-3-2</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.2.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载到指定目录~/path/，解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-6.3.2.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>由于elasticsearch 不允许使用root用户启动<br>创建一个用于启动elasticsearch 的用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd  elastic </span><br><span class="line">passwd  elastic</span><br></pre></td></tr></table></figure></p>
<p>输入密码，并确认，完成特定用户创建</p>
<p>并为该用户授权elasticsearch相关目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R elastic:elastic elasticsearch*</span><br></pre></td></tr></table></figure></p>
<p>切换到用户elastic ，创建elasticsearch目录软连接指向elastic用户的根目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">ln -s /path/to/elasticsearch ./elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>进入该目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>启动elasticsearch</p>
<p>后台启动 (daemonize)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch  -d</span><br></pre></td></tr></table></figure></p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>启动错误提示1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ERROR: [4] bootstrap checks failed</span><br><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br><span class="line">[2]: max number of threads [1024] for user [elastic] is too low, increase to at least [4096]</span><br><span class="line">[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line">[4]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br><span class="line"></span><br><span class="line">Make sure to increase the limit on the number of open files descriptors for the user running Elasticsearch to 65,536 or higher. For the .zip and .tar.gz packages, set ulimit -n 65536 as root before starting Elasticsearch, or set nofile to 65536 in /etc/security/limits.conf .</span><br></pre></td></tr></table></figure>
<p>解决：切换到root用户，编辑limits.conf 添加相关配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br></pre></td></tr></table></figure></p>
<p>添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure></p>
<p>启动错误提示2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2]: max number of threads [1024] for user [elastic] is too low, increase to at least [4096]</span><br></pre></td></tr></table></figure></p>
<p>对于第二条错误同意需要切换到root用户，进入limits.d目录下修改配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.d/90-nproc.conf</span><br></pre></td></tr></table></figure></p>
<p>修改如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 1024</span><br></pre></td></tr></table></figure></p>
<p>#修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 4096</span><br></pre></td></tr></table></figure></p>
<p>错误提示3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br></pre></td></tr></table></figure></p>
<p>第三条错误需要切换到root用户修改配置sysctl.conf<br>vi /etc/sysctl.conf </p>
<p>添加下面配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></p>
<p>并执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<p>错误提示4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</span><br></pre></td></tr></table></figure></p>
<p>原因：<br>这是在因为Centos6不支持SecComp，而ES 6.x默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。</p>
<p>解决：<br>在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></p>
<p>操作完成，现在所有的机器都能访问Linux服务器的HTTP服务了。</p>
<p>监控健康状况<br>http://[es_host]:9200/_cat/health?v<br>监控节点情况<br>http://[es_host]:9200/_cat/nodes?v<br>监控索引情况<br>http://[es_host]:9200/_cat/indices?v</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2017/01/20/2017/springcloud-collect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/20/2017/springcloud-collect/" itemprop="url">Spring Cloud 学习资料汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-20T20:13:02+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Spring-Cloud/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Cloud</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring Cloud是一系列框架的有序集合。 它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><p><a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">Spring Cloud 官网</a><br><a href="http://springcloud.cn/" target="_blank" rel="noopener">Spring Cloud 中国社区</a><br><a href="https://springcloud.cc/" target="_blank" rel="noopener">Spring Cloud 中文网</a><br><a href="http://study.163.com/courses-search?keyword=Spring%20Cloud" target="_blank" rel="noopener">网易云课堂 Spring Cloud 视频</a><br><a href="https://projects.spring.io/spring-cloud/spring-cloud.html" target="_blank" rel="noopener">Spring Cloud 参考指南- 英文版</a><br><a href="https://github.com/Nepxion/Aquarius" target="_blank" rel="noopener">Nepxion</a></p>
<h4 id="推荐博客"><a href="#推荐博客" class="headerlink" title="推荐博客"></a>推荐博客</h4><p><a href="http://www.ityouknow.com/spring-cloud" target="_blank" rel="noopener">纯洁的微笑 Spring Cloud 系列文章</a><br><a href="http://blog.didispace.com/spring-cloud-learning/" target="_blank" rel="noopener">程序猿DD Spring Cloud 从入门到精通</a><br><a href="https://windmt.com/tags/Spring-Cloud/" target="_blank" rel="noopener">windmt一spring cloud</a><br><a href="http://blog.csdn.net/column/details/15197.html" target="_blank" rel="noopener">方志朋 Spring Cloud 专栏</a><br><a href="http://xujin.org/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/" target="_blank" rel="noopener">许进 跟我学 Spring Cloud</a><br><a href="http://blog.csdn.net/liaokailin/article/category/6212338" target="_blank" rel="noopener">liaokailin的专栏 Spring Cloud</a><br><a href="http://cxytiandi.com/blog/detail/17470" target="_blank" rel="noopener">猿天地尹吉欢 Spring Cloud</a><br><a href="https://blog.battcn.com/categories/SpringCloud/" target="_blank" rel="noopener">唐亚峰 Battcn 起来学SpringCloud</a><br><a href="https://blog.csdn.net/column/details/24531.html" target="_blank" rel="noopener">yjclsx spring cloud之路</a><br><a href="http://blueskykong.com/tags/Spring-Cloud" target="_blank" rel="noopener">aoho spring cloud</a><br><a href="https://wangsong.blog.csdn.net/column/info/17373" target="_blank" rel="noopener">江南一点雨 Spring Cloud</a></p>
<h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p><a href="https://github.com/ityouknow/spring-cloud-examples" target="_blank" rel="noopener">纯洁的微笑的 Spring Cloud 示例</a><br><a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">spring cloud + vue 全家桶实战，模拟商城，完整的购物流程</a><br><a href="https://github.com/sqshq/PiggyMetrics" target="_blank" rel="noopener">PiggyMetrics-一个供个人处理财务的解决方案</a><br><a href="https://github.com/prontera/spring-cloud-rest-tcc" target="_blank" rel="noopener">基于Spring Cloud Netflix的TCC柔性事务和EDA事件驱动示例</a><br><a href="https://github.com/forezp/SpringCloudLearning" target="_blank" rel="noopener">方志朋 SpringCloudLearning</a><br><a href="https://github.com/OptionalDay/spring-cloud-vue" target="_blank" rel="noopener">一套基于springcloud + mybatis + vue全家桶</a><br><a href="https://github.com/vangao1989/cloudE" target="_blank" rel="noopener">cloudE 基于spring cloud的分布式系统架构</a><br><a href="https://github.com/lrwinx/shop" target="_blank" rel="noopener">shop spring cloud最佳实践项目实例</a><br><a href="https://gitee.com/minull/ace-security" target="_blank" rel="noopener">Cloud-Admin是国内首个基于Spring Cloud微服务化开发平台</a><br><a href="https://github.com/zhangxd1989/spring-boot-cloud" target="_blank" rel="noopener">spring-boot-cloud综合练手项目</a><br><a href="https://gitee.com/wells2333/spring-cloud-online-exam" target="_blank" rel="noopener">基于Spring Cloud的在线考试系统</a><br><a href="https://github.com/backkoms/simplemall" target="_blank" rel="noopener">基于SpringCloud的微服务架构实战案例项目，以一个简单的购物流程为示例</a><br><a href="https://gitee.com/jmdhappy/xxpay-master" target="_blank" rel="noopener">XxPay 使用Spring Cloud实现的聚合支付</a><br><a href="https://gitee.com/xfdm/FCat" target="_blank" rel="noopener">FCat项目基于 Angular 4 + Spring Cloud 的企业级基础功能框架</a><br><a href="https://gitee.com/log4j/pig" target="_blank" rel="noopener">基于Spring Cloud、oAuth2.0开发基于Vue前后分离的开发平台</a></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p><a href="https://github.com/ityouknow/awesome-spring-boot" target="_blank" rel="noopener">Spring Boot 中文索引</a><br><a href="http://tooool.org/" target="_blank" rel="noopener">程序员导航网站</a><br><a href="https://github.com/ityouknow/awesome-list" target="_blank" rel="noopener">IT行业中文资源大全</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2016/05/01/4-redis-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/01/4-redis-1/" itemprop="url">Redis系列之应用范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-01T00:16:29+08:00">
                2016-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoSQL/" itemprop="url" rel="index">
                    <span itemprop="name">NoSQL</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoSQL/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis 是互联网技术领域使用最为广泛的存储中间件，它是「Remote Dictionary Service」的首字母缩写，也就是「远程字典服务」。Redis 以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。</p>
<p>例如:<br>1.记录帖子的点赞数、评论数和点击数 (hash)。<br>2.记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。<br>3.记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。<br>4.记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。<br>5.缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。<br>6.记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。<br>7.如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID(计数器)。<br>8.收藏集和帖子之间的关系 (zset)。<br>9.记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。<br>10.缓存用户行为历史，进行恶意行为过滤 (zset,hash)。</p>
<p>当然，实际情况下需求可能也没这么多，因为在请求压力不大的情况下，很多数据都是可以直接从数据库中查询的。但请求压力一大，以前通过数据库直接存取的数据则必须要挪到缓存里来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2015/07/21/2015/handle-java-exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/21/2015/handle-java-exception/" itemprop="url">Spring MVC 统一捕获全局接口异常并返回Json</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-21T20:13:02+08:00">
                2015-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对基于Spring MVC框架开发的Web项目，我们可以通过实现接口 org.springframework.web.servlet.HandlerExceptionResolver，来定制自己工程的全局异常处理类，做到异常统一捕获处理，避免服务器端敏感信息直接暴露到客户端，根据情况构造统一的Json结构返回前端，以错误提示的方式展示给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Order(-1)</span><br><span class="line">public class MyProjectExceptionHandler implements HandlerExceptionResolver &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;</span><br><span class="line">        </span><br><span class="line">        ModelAndView mv = new ModelAndView();</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">        response.setStatus(HttpStatus.OK.value()); //设置状态码</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE); //设置ContentType</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;); //避免乱码</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache, must-revalidate&quot;);</span><br><span class="line">       </span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">            response.getWriter().write(&quot;你需要响应给前端的信息&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        	//todo error log</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //todo log </span><br><span class="line"></span><br><span class="line">        return mv;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2015/03/21/mysql-master-slave/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/21/mysql-master-slave/" itemprop="url">基于Mysql binglog的主从同步搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-03-21T23:13:02+08:00">
                2015-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是MySQL主从复制"><a href="#什么是MySQL主从复制" class="headerlink" title="什么是MySQL主从复制"></a>什么是MySQL主从复制</h2><p>简单来说就是保证主SQL（Master）和从SQL（Slave）的数据是一致性的，向Master插入数据后，Slave会自动从Master把修改的数据同步过来（有一定的延迟），通过这种方式来保证数据的一致性，就是主从复制</p>
<h2 id="MySQL主从能解决什么问题"><a href="#MySQL主从能解决什么问题" class="headerlink" title="MySQL主从能解决什么问题"></a>MySQL主从能解决什么问题</h2><h3 id="一、高可用"><a href="#一、高可用" class="headerlink" title="一、高可用"></a>一、高可用</h3><p>因为数据都是相同的，所以当Master挂掉后，可以指定一台Slave充当Master继续保证服务运行，因为数据是一致性的（如果当插入Master就挂掉，可能不一致，因为同步也需要时间），当然这种配置不是简单的把一台Slave充当Master，毕竟还要考虑后续的Salve同步Master，当然本文并不是将高可用的配置，所以这里就不多讲了</p>
<h3 id="二、负载均衡"><a href="#二、负载均衡" class="headerlink" title="二、负载均衡"></a>二、负载均衡</h3><p>因为读写分离也算是负载均衡的一种，所以就不单独写了，因为一般都是有多台Slave的，所以可以将读操作指定到Slave服务器上（需要代码控制），然后再用负载均衡来选择那台Slave来提供服务，同时也可以吧一些大量计算的查询指定到某台Slave，这样就不会影响Master的写入以及其他查询</p>
<h3 id="三、数据备份"><a href="#三、数据备份" class="headerlink" title="三、数据备份"></a>三、数据备份</h3><p>一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全</p>
<h3 id="四、业务模块化"><a href="#四、业务模块化" class="headerlink" title="四、业务模块化"></a>四、业务模块化</h3><p>可以一个业务模块读取一个Slave，再针对不同的业务场景进行数据库的索引创建和根据业务选择MySQL存储引擎</p>
<h3 id="五、高扩展（硬件扩展）"><a href="#五、高扩展（硬件扩展）" class="headerlink" title="五、高扩展（硬件扩展）"></a>五、高扩展（硬件扩展）</h3><p>主从复制支持2种扩展方式</p>
<h4 id="1、scale-up"><a href="#1、scale-up" class="headerlink" title="1、scale-up"></a>1、scale-up</h4><p>向上扩展或者纵向扩展，主要是提供比现在服务器更好性能的服务器，比如增加CPU和内存以及磁盘阵列等，因为有多台服务器，所以可扩展性比单台更大</p>
<h4 id="2、scale-out"><a href="#2、scale-out" class="headerlink" title="2、scale-out"></a>2、scale-out</h4><p>向外扩展或者横向扩展，是指增加服务器数量的扩展，这样主要能分散各个服务器的压力</p>
<h2 id="主从复制的缺点"><a href="#主从复制的缺点" class="headerlink" title="主从复制的缺点"></a>主从复制的缺点</h2><h3 id="一、成本增加"><a href="#一、成本增加" class="headerlink" title="一、成本增加"></a>一、成本增加</h3><p>无可厚非的是搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启二进制日志，所以也会造成额外的性能消耗</p>
<h3 id="二、数据延迟"><a href="#二、数据延迟" class="headerlink" title="二、数据延迟"></a>二、数据延迟</h3><p>Slave从Master复制过来肯定是会有一定的数据延迟的，所以当刚插入就出现查询的情况，可能查询不出来，当然如果是插入者自己查询，那么可以直接从Master中查询出来，当然这个也是需要用代码来控制的</p>
<h3 id="三、写入更慢"><a href="#三、写入更慢" class="headerlink" title="三、写入更慢"></a>三、写入更慢</h3><p>主从复制主要是针对读远大于写或者对数据备份实时性要求较高的系统中，因为Master在写中需要更多操作，而且只有一台写入的Master（因为我目前只会配置一台写入Master，最多就是有从Master的Slave，用来在Master挂掉后替换成Master，平时不对外进行服务），所以写入的压力并不能被分散，当然如果直接怎么解决这个问题的话，欢迎留言指教</p>
<h2 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h2><p>MySQL5.6开始主从复制有两种方式：基于日志（binlog）、基于GTID（全局事务标示符）。<br>本文只涉及基于日志binlog的主从配置</p>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>1、Master将数据改变记录到二进制日志(binary log)中，也就是配置文件log-bin指定的文件，这些记录叫做二进制日志事件(binary log events)<br>2、Slave通过I/O线程读取Master中的binary log events并写入到它的中继日志(relay log)<br>3、Slave重做中继日志中的事件，把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储，从而实现将改变反映到它自己的数据(数据重放)</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>1、主从服务器操作系统版本和位数一致<br>2、Master和Slave数据库的版本要一致<br>3、Master和Slave数据库中的数据要一致<br>4、Master开启二进制日志，Master和Slave的server_id在局域网内必须唯一</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="硬件需求"><a href="#硬件需求" class="headerlink" title="硬件需求"></a>硬件需求</h3><p>两台或两台以上安装了相同版本的MySQL（我没有试过不同版本会不会有问题，有兴趣的可以试试），当然这个可以用虚拟机或者Docker代替，个人推荐用Docker，比虚拟机消耗少太多了，当然用起来可能没有虚拟机那么方便，但是却不用挨个环境配置了</p>
<h3 id="配置Master"><a href="#配置Master" class="headerlink" title="配置Master"></a>配置Master</h3><h4 id="一、安装数据库"><a href="#一、安装数据库" class="headerlink" title="一、安装数据库"></a>一、安装数据库</h4><h4 id="二、配置my-cnf"><a href="#二、配置my-cnf" class="headerlink" title="二、配置my.cnf"></a>二、配置my.cnf</h4><p>不同的系统my.cnf路径不同，所以我们只讲解牵扯修改的地方。添加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP,注意要唯一</span><br><span class="line">server_id=100  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span><br><span class="line">log-bin=edu-mysql-bin  </span><br><span class="line">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>
<h4 id="配置完成后重启mysql"><a href="#配置完成后重启mysql" class="headerlink" title="配置完成后重启mysql"></a>配置完成后重启mysql</h4><h3 id="关于复制过滤"><a href="#关于复制过滤" class="headerlink" title="关于复制过滤"></a>关于复制过滤</h3><h4 id="复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤："><a href="#复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤：" class="headerlink" title="复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤："></a>复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤：</h4><p>1、在Master上过滤二进制日志中的事件<br>2、在Slave上过滤中继日志中的事件。</p>
<h4 id="复制类型"><a href="#复制类型" class="headerlink" title="复制类型"></a>复制类型</h4><h4 id="1、基于语句的复制"><a href="#1、基于语句的复制" class="headerlink" title="1、基于语句的复制"></a>1、基于语句的复制</h4><p>在Master上执行的SQL语句，在Slave上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制</p>
<h4 id="2、基于行的复制"><a href="#2、基于行的复制" class="headerlink" title="2、基于行的复制"></a>2、基于行的复制</h4><p>把改变的内容复制到Slave，而不是把命令在Slave上执行一遍。从MySQL5.0开始支持</p>
<h4 id="3、混合类型的复制"><a href="#3、混合类型的复制" class="headerlink" title="3、混合类型的复制"></a>3、混合类型的复制</h4><p>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制</p>
<h3 id="三、创建数据同步用户"><a href="#三、创建数据同步用户" class="headerlink" title="三、创建数据同步用户"></a>三、创建数据同步用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class="line"></span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure>
<p>这里主要是要授予用户REPLICATION SLAVE权限和REPLICATION CLIENT权限</p>
<h3 id="配置Slave"><a href="#配置Slave" class="headerlink" title="配置Slave"></a>配置Slave</h3><h4 id="一、安装数据库-1"><a href="#一、安装数据库-1" class="headerlink" title="一、安装数据库"></a>一、安装数据库</h4><h4 id="二、配置my-cnf-1"><a href="#二、配置my-cnf-1" class="headerlink" title="二、配置my.cnf"></a>二、配置my.cnf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP,注意要唯一</span><br><span class="line">server_id=101  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin=edu-mysql-slave1-bin  </span><br><span class="line">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=edu-mysql-relay-bin  </span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1  </span><br><span class="line">## 防止改变数据(除了特殊的线程)</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>
<p>如果Slave为其它Slave的Master时，必须设置bin_log。配置完成后重启mysql</p>
<h4 id="完成Master和Slave链接"><a href="#完成Master和Slave链接" class="headerlink" title="完成Master和Slave链接"></a>完成Master和Slave链接</h4><h4 id="一、初始化数据"><a href="#一、初始化数据" class="headerlink" title="一、初始化数据"></a>一、初始化数据</h4><p>保证Master和Slave除不同步的数据库，其他库的数据一致</p>
<h4 id="二、查询Master状态"><a href="#二、查询Master状态" class="headerlink" title="二、查询Master状态"></a>二、查询Master状态</h4><p>在Master中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure></p>
<p>记录下返回结果的File列和Position列的值</p>
<h4 id="三、Slave中设置Master信息"><a href="#三、Slave中设置Master信息" class="headerlink" title="三、Slave中设置Master信息"></a>三、Slave中设置Master信息</h4><p>在Slave中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.1.100&apos;, master_user=&apos;slave&apos;, master_password=&apos;123456&apos;, master_port=3306, master_log_file=&apos;edu-mysql-bin.000001&apos;, master_log_pos=1389, master_connect_retry=30;</span><br></pre></td></tr></table></figure></p>
<p>上面执行的命令的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">master_host=&apos;192.168.1.100&apos; ## Master的IP地址</span><br><span class="line"></span><br><span class="line">master_user=&apos;slave&apos; ## 用于同步数据的用户（在Master中授权的用户）</span><br><span class="line"></span><br><span class="line">master_password=&apos;123456&apos; ## 同步数据用户的密码</span><br><span class="line"></span><br><span class="line">master_port=3306 ## Master数据库服务的端口</span><br><span class="line"></span><br><span class="line">masterlogfile=&apos;edu-mysql-bin.000001&apos; ##指定Slave从哪个日志文件开始读复制数据（Master上执行命令的结果的File字段）</span><br><span class="line"></span><br><span class="line">masterlogpos=429 ## 从哪个POSITION号开始读（Master上执行命令的结果的Position字段）</span><br><span class="line"></span><br><span class="line">masterconnectretry=30 ##当重新建立主从连接时，如果连接建立失败，间隔多久后重试。单位为秒，默认设置为60秒，同步延迟调优参数。</span><br></pre></td></tr></table></figure></p>
<h4 id="四、查看主从同步状态"><a href="#四、查看主从同步状态" class="headerlink" title="四、查看主从同步状态"></a>四、查看主从同步状态</h4><h4 id="在Slave中执行命令"><a href="#在Slave中执行命令" class="headerlink" title="在Slave中执行命令"></a>在Slave中执行命令</h4><p>show slave status;<br>可看到SlaveIOState为空， SlaveIORunning和SlaveSQLRunning是No，表明Slave还没有开始复制过程。相反SlaveIORunning和SlaveSQLRunning是Yes表明已经开始工作了</p>
<h4 id="五、开启主从同步"><a href="#五、开启主从同步" class="headerlink" title="五、开启主从同步"></a>五、开启主从同步</h4><h4 id="在Slave中执行命令-1"><a href="#在Slave中执行命令-1" class="headerlink" title="在Slave中执行命令"></a>在Slave中执行命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<p>查询查看主从同步状态，会发现SlaveIORunning和SlaveSQLRunning是Yes了，表明开启成功</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2015/02/21/mysql-remove-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/21/mysql-remove-data/" itemprop="url">基于Mysql特性对删除大表数据的一些建议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-02-21T20:13:02+08:00">
                2015-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>生产环境，往往需要更新/删除大量的数据，由于很可能消耗太多的IO资源，对于生产繁忙的系统，需要小心，以避免对生产环境造成影响。<br>删除大量数据还有一些副作用，比如主从延时、数据文件无法收缩、锁表等。<br>以下是一些要指引和规则：<br>1、批量删除，这样往往可以工作得更快，你可能需要在每次批量删除前sleep一段时间，控制删除的频率，这样的目的是减少对生产系统的IO冲击，把符合平均分布，避免从库滞后太多；<br>2、可以考虑分区表技术，我很少用分区表，但删除一个分区，显然比删除大量数据简单方便的多，这也是分区表清理/归档数据的优势所在；<br>3、按照主键的序列分批分批，或者基于时间分批分批，你总可以找到一种方式批量删除，如果实在没有批量删除的方式，可能你的表结构设计得不好；<br>4、基于硬件的性能，每批删除的记录数，可以选择几百到几千到几万的数据量，但不要太大，MySQL很难同时处理好大事务和随机小事务；<br>5、如果要删除大部分数据，那么可以考虑的方式是，创建一个新表，insert要保留的数据，然后切换表；<br>6、对于大表(InnoDB)删除大量数据，如果是一个很大的事务，中止删除数据的操作，可能需要几倍的时间用于回滚，导致严重的IO瓶颈，而批量删除可以让我们的回滚恢复得快得多。<br>7、需要留意空间的释放，选择独立表空间会更有利于释放空间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2013/02/10/3-custom-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2013/02/10/3-custom-cache/" itemprop="url">Java实现简单的缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-02-10T00:13:48+08:00">
                2013-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="通过map模拟缓存实现"><a href="#通过map模拟缓存实现" class="headerlink" title="通过map模拟缓存实现"></a>通过map模拟缓存实现</h4><h5 id="1-定义缓存包装类"><a href="#1-定义缓存包装类" class="headerlink" title="1.定义缓存包装类"></a>1.定义缓存包装类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">        private String key;//缓存ID</span><br><span class="line">        private Object value;//缓存数据</span><br><span class="line">        private long timeOut;//更新时间</span><br><span class="line">        private boolean expired; //是否终止</span><br><span class="line">        public Cache() &#123;</span><br><span class="line">                super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Cache(String key, Object value, long timeOut, boolean expired) &#123;</span><br><span class="line">                this.key = key;</span><br><span class="line">                this.value = value;</span><br><span class="line">                this.timeOut = timeOut;</span><br><span class="line">                this.expired = expired;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getKey() &#123;</span><br><span class="line">                return key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public long getTimeOut() &#123;</span><br><span class="line">                return timeOut;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getValue() &#123;</span><br><span class="line">                return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setKey(String string) &#123;</span><br><span class="line">                key = string;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setTimeOut(long l) &#123;</span><br><span class="line">                timeOut = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setValue(Object object) &#123;</span><br><span class="line">                value = object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isExpired() &#123;</span><br><span class="line">                return expired;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setExpired(boolean b) &#123;</span><br><span class="line">                expired = b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-定义缓存工具类"><a href="#2-定义缓存工具类" class="headerlink" title="2.定义缓存工具类"></a>2.定义缓存工具类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">public class CacheManager &#123;</span><br><span class="line">    private static HashMap cacheMap = new HashMap();</span><br><span class="line"></span><br><span class="line">    //单实例构造方法</span><br><span class="line">    private CacheManager() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    //获取布尔值的缓存</span><br><span class="line">    public static boolean getSimpleFlag(String key)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return (Boolean) cacheMap.get(key);</span><br><span class="line">        &#125;catch(NullPointerException e)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static long getServerStartdt(String key)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Long)cacheMap.get(key);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置布尔值的缓存</span><br><span class="line">    public synchronized static boolean setSimpleFlag(String key,boolean flag)&#123;</span><br><span class="line">        if (flag &amp;&amp; getSimpleFlag(key)) &#123;//假如为真不允许被覆盖</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cacheMap.put(key, flag);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static boolean setSimpleFlag(String key,long serverbegrundt)&#123;</span><br><span class="line">        if (cacheMap.get(key) == null) &#123;</span><br><span class="line">            cacheMap.put(key,serverbegrundt);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //得到缓存。同步静态方法</span><br><span class="line">    private synchronized static Cache getCache(String key) &#123;</span><br><span class="line">        return (Cache) cacheMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否存在一个缓存</span><br><span class="line">    private synchronized static boolean hasCache(String key) &#123;</span><br><span class="line">        return cacheMap.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清除所有缓存</span><br><span class="line">    public synchronized static void clearAll() &#123;</span><br><span class="line">        cacheMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清除某一类特定缓存,通过遍历HASHMAP下的所有对象，来判断它的KEY与传入的TYPE是否匹配</span><br><span class="line">    public synchronized static void clearAll(String type) &#123;</span><br><span class="line">        Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">        String key;</span><br><span class="line">        ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                key = (String) entry.getKey();</span><br><span class="line">                if (key.startsWith(type)) &#123; //如果匹配则删除掉</span><br><span class="line">                    arr.add(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int k = 0; k &lt; arr.size(); k++) &#123;</span><br><span class="line">                clearOnly(arr.get(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清除指定的缓存</span><br><span class="line">    public synchronized static void clearOnly(String key) &#123;</span><br><span class="line">        cacheMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //载入缓存</span><br><span class="line">    public synchronized static void putCache(String key, Cache obj) &#123;</span><br><span class="line">        cacheMap.put(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存信息</span><br><span class="line">    public static Cache getCacheInfo(String key) &#123;</span><br><span class="line"></span><br><span class="line">        if (hasCache(key)) &#123;</span><br><span class="line">            Cache cache = getCache(key);</span><br><span class="line">            if (cacheExpired(cache)) &#123; //调用判断是否终止方法</span><br><span class="line">                cache.setExpired(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return cache;</span><br><span class="line">        &#125;else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //载入缓存信息</span><br><span class="line">    public static void putCacheInfo(String key, Cache obj, long dt,boolean expired) &#123;</span><br><span class="line">        Cache cache = new Cache();</span><br><span class="line">        cache.setKey(key);</span><br><span class="line">        cache.setTimeOut(dt + System.currentTimeMillis()); //设置多久后更新缓存</span><br><span class="line">        cache.setValue(obj);</span><br><span class="line">        cache.setExpired(expired); //缓存默认载入时，终止状态为FALSE</span><br><span class="line">        cacheMap.put(key, cache);</span><br><span class="line">    &#125;</span><br><span class="line">    //重写载入缓存信息方法</span><br><span class="line">    public static void putCacheInfo(String key,Cache obj,long dt)&#123;</span><br><span class="line">        Cache cache = new Cache();</span><br><span class="line">        cache.setKey(key);</span><br><span class="line">        cache.setTimeOut(dt+System.currentTimeMillis());</span><br><span class="line">        cache.setValue(obj);</span><br><span class="line">        cache.setExpired(false);</span><br><span class="line">        cacheMap.put(key,cache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断缓存是否终止</span><br><span class="line">    public static boolean cacheExpired(Cache cache) &#123;</span><br><span class="line">        if (null == cache) &#123; //传入的缓存不存在</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long nowDt = System.currentTimeMillis(); //系统当前的毫秒数</span><br><span class="line">        long cacheDt = cache.getTimeOut(); //缓存内的过期毫秒数</span><br><span class="line">        if (cacheDt &lt;= 0||cacheDt&gt;nowDt) &#123; //过期时间小于等于零时,或者过期时间大于当前时间时，则为FALSE</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123; //大于过期时间 即过期</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存中的大小</span><br><span class="line">    public static int getCacheSize() &#123;</span><br><span class="line">        return cacheMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取指定的类型的大小</span><br><span class="line">    public static int getCacheSize(String type) &#123;</span><br><span class="line">        int k = 0;</span><br><span class="line">        Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">        String key;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                key = (String) entry.getKey();</span><br><span class="line">                if (key.indexOf(type) != -1) &#123; //如果匹配则删除掉</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存对象中的所有键值名称</span><br><span class="line">    public static ArrayList&lt;String&gt; getCacheAllkey() &#123;</span><br><span class="line">        ArrayList a = new ArrayList();</span><br><span class="line">        try &#123;</span><br><span class="line">            Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                a.add((String) entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;&#125; finally &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存对象中指定类型 的键值名称</span><br><span class="line">    public static ArrayList&lt;String&gt; getCacheListkey(String type) &#123;</span><br><span class="line">        ArrayList a = new ArrayList();</span><br><span class="line">        String key;</span><br><span class="line">        try &#123;</span><br><span class="line">            Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                key = (String) entry.getKey();</span><br><span class="line">                if (key.indexOf(type) != -1) &#123;</span><br><span class="line">                    a.add(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;&#125; finally &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-缓存测试类"><a href="#3-缓存测试类" class="headerlink" title="3.缓存测试类"></a>3.缓存测试类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(CacheManager.getSimpleFlag(&quot;alksd&quot;));</span><br><span class="line">//        CacheManager.putCache(&quot;foot ball&quot;, new Cache());</span><br><span class="line">//        CacheManager.putCache(&quot;basket ball&quot;, new Cache());</span><br><span class="line">//        CacheManager.putCache(&quot;apple&quot;, new Cache());</span><br><span class="line">//        CacheManager.clearOnly(&quot;&quot;);</span><br><span class="line">//        Cache c = new Cache();</span><br><span class="line">//        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">//            CacheManager.putCache(&quot;&quot; + i, c);</span><br><span class="line">//        &#125;</span><br><span class="line">//        CacheManager.putCache(&quot;key1&quot;, c);</span><br><span class="line">//        CacheManager.putCache(&quot;key2&quot;, c);</span><br><span class="line">//        CacheManager.putCache(&quot;key3&quot;, c);</span><br><span class="line">//        System.out.println(&quot;清除前的大小：&quot;+CacheManager.getCacheSize());</span><br><span class="line">//        CacheManager.getCacheAllkey();</span><br><span class="line">//        CacheManager.clearAll(&quot;aaaa&quot;);</span><br><span class="line">//        System.out.println(&quot;清除后的大小：&quot;+CacheManager.getCacheSize());</span><br><span class="line">//        CacheManager.getCacheAllkey();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">luchangwei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luchangwei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
