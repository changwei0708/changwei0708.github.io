<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="fz00x0zf&#39;s blog">
<meta property="og:url" content="http://changwei0708.github.io/index.html">
<meta property="og:site_name" content="fz00x0zf&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fz00x0zf&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://changwei0708.github.io/"/>





  <title>fz00x0zf's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fz00x0zf's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-日志">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            日志
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-玩儿">
          <a href="/play/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-play"></i> <br />
            
            玩儿
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2019/07/10/2019/what-is-io-multiplexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/2019/what-is-io-multiplexing/" itemprop="url">什么是 I/O 多路复用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-10T21:13:48+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/I-O/" itemprop="url" rel="index">
                    <span itemprop="name">I/O</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在高并发环境下，web 服务器需要处理成千上万的客户端连接，如何最大限度发挥单台机器的性能，使之在处理大量连接时仍保持较低的负载，这是个很重要的课题。本文介绍下解决此类问题的一种很经典的方式：I/O 多路复用。<br>传统 I/O</p>
<p>为了了解 I/O 多路复用是怎么产生的，我们先看下传统的网络 I/O 模式，也被称为 BIO(Blocking IO)。<br>在编写服务端网络程序时，传统的方式是这样的：创建套接字并绑定端口，然后用一个 while 循环，在循环里调用 accept，程序会阻塞，一旦有连接到来，accept 就返回，然后针对该连接做相应的读写处理。形式像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建套接字</span><br><span class="line">ServerSocket serverSocket = new ServerSocket();</span><br><span class="line">// 绑定套接字</span><br><span class="line">serverSocket.bind(new InetSocketAddress(2345));</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">while(true) &#123;</span><br><span class="line">    // 调用 accept 等待客户端连接，程序阻塞，当有连接到达时才返回</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    // 对套接字读写</span><br><span class="line">    handle(socket);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">// 关闭套接字</span><br><span class="line">serverSocket.colse();</span><br></pre></td></tr></table></figure>
<p>一般我们在刚学网络编程时，都会用这种的方式，也被称为单线程模式，这种模式的特点就是简单直白，方式固定，写起来较容易。但有个致命问题：同一时间，它只能处理一个客户端请求，因为它直接是在主线程中处理请求的，只有在上一个请求处理完毕，才能接着处理下一个请求，一旦某个请求处理较慢，那后面的请求只能等待。<br>把上面的单线程模式改下，对每个连接，新开一个线程单独进行读写处理，这样就可以同时处理多个连接了，形式如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建和绑定步骤不变</span><br><span class="line">   // ...</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">       Socket socket = serverSocket.accept();</span><br><span class="line">       // 新开一个线程，对套接字读写</span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           handle(socket);</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这种模式就是多线程模式，比上面的那种要高级一点，它可以同时处理多个连接，因为对每个连接的处理都是在一个单独的线程中，和主线程分离开来，主线程可以继续 accept 客户端连接。<br>但这种模式仍然存在问题：<br>线程的创建和销毁的成本是很高的，创建线程需要消耗内存，1 个线程需要耗费 512K 到 1M 的内存，几十上百个可能看不出来，成千上万的话，内存很快就耗尽。<br>线程池能解决部分问题，但当请求过多，线程池仍然处理不过来，导致大量的请求超时，更严重的是，大量的线程会导致大量的线程切换，线程切换，或者说上下文切换是需要 CPU 开销的，线程切换越频繁，真正分配给业务的 CPU 资源就越少。<br>上面的两种模式，不管是单线程模式还是多线程模式，我们都称之为阻塞模式(Blocking I/O)，是因为它们对连接的处理，都是以线程为基石，在一个线程中处理一个 socket 的读写，但实际情况是，线程的大部分时间都是在等待数据的到来。当调用 recvfrom 时，线程会等待着客户端的数据到达网卡，然后网卡把数据交给内核，然后内核再把数据拷贝到用户进程空间，这时 recvfrom 才会返回。这个过程<br>中，线程的绝大部分时间都是处于等待数据状态，什么也做不了。而下面要介绍的 I/O 多路复用，就是为解决此问题而生。<br>I/O 多路复用</p>
<p>上面我们分析了由线程直接处理网络 I/O 的低效原因，想象下，当我们调用 recvfrom，发现数据还没准备好，就不傻等了，而是告诉系统：等数据准备好了，你告诉我下，我再来读。这时线程可以先去干点别的，比如去检查下有没有其他的连接。过了一会儿，系统产生了一个可读事件，告诉我们，你要的数据准备好了，可以来读了，这时就可以继续回到刚才的地方读取数据。这样效率不是就好多了吗？因为在等数据的同时，我还可以干其他的事情。这是一种非阻塞模式，那么这种“数据好了通知我们”的机制怎么实现呢？<br>其实，操作系统已经给我们提供了 select，poll，epoll，kqueue 这样的系统调用，来完成我们上面的要求，这些系统调主要干一件事：监听一个或多个文件描述符上的各类事件，一旦文件描述符上有事件产生，就返回。文件描述符，是 Unix 系统下的一个叫法，也称为 fd(file descriptor)，下文统称为 fd，fd 对应于 Windows 平台下的句柄（handle），一个文件描述符唯一标识了某进程打开的某个文件，Unix 的设计哲学就是一切皆文件，socket 也是文件，可以作为 fd 被监听。监听哪些事件呢？有：连接事件（acceptable），可读事件（readable），可写事件（writeable），关闭事件（closeable）等。于是通过这类系统调用，监听多个 fd，一旦某个 fd 上有某个事件产生，调用就会返回，于是我们知道“有事发生”，然后根据事件的类型，做不同的处理。因此，有时也把这种模型称为事件驱动模型，或者 Reactor 模式。<br>I/O 多路复用的关键，是它可以让内核监听 fd 的事件，而且可以同时监听多个 fd，和用一个线程处理一个 socket 连接有根本的区别，它只需要一个线程或进程，就管理了多个连接，我们可以用一句话来概括 I/O 多路复用：在一个线程或一个进程中，监听了多个 fd。这里的复用，指的是多个 fd，或者说多个连接，复用了一个线程或者进程。<br>I/O 多路复用的三种方式</p>
<p>select</p>
<p>首先来看 select，它的原型如下：<br>1<br>int select (int nfds, fd_set <em>readfds, fd_set </em>writefds, fd_set <em>exceptfds, struct timeval </em>timeout);</p>
<p>nfds 为需要监听的最大 fd 个数+1。<br>中间的三个参数 readfds、writefds 和 exceptfds 指定我们要让内核监听读、写和异常条件的 fd。如果对某一个的条件不感兴趣，就可以把它设为空指针。fd_set 结构体可以理解为集合，存放的是 fd，可以通过下面的宏处理这三种 fd_set:<br>1<br>2<br>3<br>4<br>FD_CLR(inr fd, fd_set <em>fdset);   // 清除 fd set 中相关 fd 的位<br>FD_ISSET(int fd, fd_set </em>fdset); // 测试 fd set 中相关 fd 的位是否为真<br>FD_SET(int fd, fd_set <em>fdset);  //  设置 fd set 中相关 fd 的位<br>FD_ZERO(fd_set </em>fdset);         //  清除 fd set 的全部位<br>select 的使用方法，我们看下面的例子，为了简单起见，我们只传入了可读事件的 fd，对其他的字段设置为 NULL，表示我们不感兴趣。在 for 事件循环中，调用 select，一旦 fd 有可读事件，就调用 read 处理读事件。其中判断可读是通过调用 FD_ISSET 来完成。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>ssize_t nbytes;<br>for (;;) {<br>    /<em> select call happens here </em>/<br>    if (select(FD_SETSIZE, &amp;read_fds, NULL, NULL, NULL) &lt; 0) {<br>        perror(“select”);<br>        exit(EXIT_FAILURE);<br>    }<br>    for (int i = 0; i &lt; FD_SETSIZE; i++) {<br>        if (FD_ISSET(i, &amp;read_fds)) {<br>            /<em> read call happens here </em>/<br>            if ((nbytes = read(i, buf, sizeof(buf))) &gt;= 0) {<br>                handle_read(nbytes, buf);<br>            } else {<br>                /<em> real version needs to handle EINTR correctly </em>/<br>                perror(“read”);<br>                exit(EXIT_FAILURE);<br>            }<br>        }<br>    }<br>}</p>
<p>运行后，程序会阻塞在 select，一旦 fds 中有可读事件，select 即返回，然后就可以遍历，查看到底是那个 fd 可读，并做相应处理。<br>I/O 多路复用概念被提出来后，select 是第一个实现它的系统调用，它是一个古老的实现，在 20 世纪 80 年代就诞生了，几乎所有的平台上都支持，良好跨平台支持也是它的一个优点。然而，它的缺点也不可忽视：<br>监听的 fd 数量存在最大限制，在 Linux 上这个最大值是 1024，这在 select 诞生的那个年代来说足够了，但对现在互联网信息爆炸时代来说，极大限制了 select 的可用性。<br>其次，一旦监听的 fd 上有事件产生，select 仅仅会返回，但并不会告诉我们是哪些 fd 产生了事件，这时需要自己遍历所有的 fdset，依次检查每个 fd 上的事件标志位。显然，遍历的这个过程时间复杂度是 O(n)。因此，即使把上面的最大监听数改大，但带来的问题是效率的降低。<br>poll</p>
<p>再来看 poll，它是 select 的改进版，主要改进点有：<br>去掉了 1024 这个最大监听数的限制。用户可以自定义监听 fd 数。<br>简化了 select 调用方式，它的原型如下：<br>1<br>int poll (struct pollfd *fds, unsigned int nfds, int timeout);<br>不同于 select 使用三个位图来表示三个 fdset 的方式，poll 使用一个 pollfd 的指针实现，pollfd 结构如下：<br>1<br>2<br>3<br>4<br>5<br>typedef struct pollfd {<br>        int fd;                         // file descriptor<br>        short events;                   // requested events to watch<br>        short revents;                  // returned events witnessed<br>} pollfd_t;</p>
<p>pollfd 结构包含了要监听的 event 和发生的 event，不再使用 select “参数-值”传递的方式，使得 poll 支持的 fd 集合限制远大于 select 的 1024。但是，poll 并没有解决 select 最根本的问题：它依然需要遍历所有 fd 来检查事件，遍历的时间复杂度依然是 O(n)。<br>epoll</p>
<p>再来看看 epoll，epoll 和上面的 select 和 poll 有着本质的区别，除了没有最大监听数限制外，它还有一个最大特点：只返回有事件发生的 fd，所以不需要遍历所有监听的 fd 来找到哪些 fd 产生了事件。因此，它的时间复杂度为 O(k)，其中 k 为产生事件的 fd 数。因此，epoll 的效率不会像 select 和 poll 那样，随着监听 fd 的数量的增长而下降，那么它是怎么做的呢？来看下使用 epoll 时需要的三个系统调用：<br>1<br>2<br>3<br>int epoll_create(int size);<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event);<br>int epoll_wait(int epfd, struct epoll_event </em>events,int maxevents, int timeout);</p>
<p>epoll_create：创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 select 中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>epoll_ctl：对指定 fd 执行 op 操作，epfd 是 epoll_create 的返回值。op 表示操作，用三个宏来表示：添加 EPOLL_CTL_ADD，删除 EPOLL_CTL_DEL，修改 EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件，epoll_event 告诉内核需要监听什么事。<br>epoll_wait：等待 epfd 上的 io 事件，最多返回 maxevents 个事件。<br>上面对函数的解释可能比较抽象，简单来讲：当我们调用 epoll_create 时，内核就创建了一棵红黑树和一个就绪（Ready）链表，其中，红黑数用于存储后面 epoll_ctl 传过来的 fd，以支持高效的查找、插入和删除。就绪链表用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个就绪链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。使用 epoll 的方式大概长这样：<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35</p>
<p>#define MAX_EVENTS 10;<br>int event_count;<br>// 这里是创建网络程序的一般步骤<br>// … socket(), bind(), listen()</p>
<p>// 创建epoll文件描述符，出错返回 -1<br>// int epoll_create(int size) 从Linux2.6.8开始，size 值被忽略，不过为保持兼容需要设定为一个正整数<br>int epollfd = epoll_create(1024);<br>struct epoll_event ev, events_in[MAX_EVENTS]; // 记录套接字相关信息<br>ev.events = EPOLLIN; // 监视有数据可读事件<br>ev.data.fd = fd; // 文件描述符数据，其实这里可以放任何数据。</p>
<p>// 加入监听列表，当fd上有对应事件产生时，epoll_wait会将epoll_event填充到events_in数组里<br>// 出错返回 -1<br>epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev);</p>
<p>while(1) {<br>    // 等待事件，epoll_wait 会将事件填充至 events_in 内<br>    // 返回获得的事件数量，若超时且没有任何事件返回0，出错返回 -1。timeout 设置为 -1 表示无限等待。<br>    int event_count = epoll_wait(epollfd, events_in, MAX_EVENTS, -1);<br>    for (int i = 0; i&lt;event_count; i++) { // 遍历所有事件<br>        if (events_in[i].data.fd == fd) { // 新连接请求<br>            int new_fd = accept(fd, NULL, NULL);<br>            ev.events = EPOLLIN;<br>            setnonblocking(new_fd);  // 如果要使用Edge Trigger还需将 new_fd 设为非阻塞<br>            ev.data.fd = new_fd;<br>            epoll_ctl(epollfd, EPOLL_CTL_ADD, new_fd, &amp;ev); // 将新连接加入监视列表<br>        } else {  // 其他的事件处理，如读写事件<br>            int new_fd = events_in[i].data.fd;<br>            // … handle(new_fd);<br>            epoll_ctl(epollfd, EPOLL_CTL_DEL, new_fd, NULL); // 不再监听fd，最后一个参数被忽略<br>            close(new_fd);<br>        }<br>    }<br>}<br>epoll 有两种工作模式：LT（level trigger）模式和 ET（edge trigger）模式，也叫水平触发和边沿触发，默认的是 LT 模式<br>LT 模式：当 epoll_wait 检测到 fd 事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。<br>ET 模式：当 epoll_wait 检测到 fd 事件发生，只有当 fd 事件变化时，即从 unreadable 变为 readable 或从 unwritable 变为 writable 时，它才返回事件 fd，因此应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此 fd 事件。<br>一句话：如果 fd 上有事件发生，LT 模式下会一直通知你，ET 模式只会通知一次。<br>因此，如果 epoll 工作在 ET 模式，正确的读写方式应该如下所述，具体描述可以参考这篇文章，这里只说结论：<br>读：只要可读，就一直读，直到返回 0，或者 errno = EAGAIN<br>写：只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN<br>ET 模式也称为高速模式，在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接字模式，以避免由于一个 fd 的阻塞读/阻塞写操作把处理多个 fd 的任务饿死，如上面代码的第 25 行：<br>1<br>setnonblocking(new_fd);</p>
<p>epoll 的上述特点，使 I/O 多路复用系统的性能提升到一个新的台阶。当管理的连接数不多时，使用 select/poll 和使用 epoll 的差别不大，但是当连接数上十万百万时，就会发现 epoll 的效率远高于 select/poll。因为在互联网大量并发的连接场景下，实际同一时刻，真正活跃（Active）的连接，其实只占少数，其他的都是空闲（idle）状态。epoll 不遍历所有连接，只对活跃的连接做处理。<br>需要注意的是：epoll 是 Linux 2.6 内核版本引入，只用于 Linux 平台，BSD 或 MacOS 对应的实现就是 kqueue，Windows 下就是 IOCP。<br>怎么使用</p>
<p>实际上，当我们使用 I/O 多路复用时，也很少会直接调用 select/poll/epoll，这样开发周期长，对开发者有较高要求，出问题难以调试，直接使用现有的库会大大降低开发难度，如 libevent，netty 等，他们对于不同的平台底层使用不同的方式，比如你是 MacOS，底层就用 kqueue，如果是 Linux 2.6或更新，则用 epoll。这些库提供了一套统一的 API，好处是允许你的代码在不同平台上运行而不需要改变任何代码，用户只需直接使用即可。<br>I/O 多路复用的问题</p>
<p>细心的同学会发现，I/O 多路复用是单线程的，不能充分利用多核；同时，单线程模型事件处理中，不能有阻塞，一旦发生阻塞，会大大降低该模型性能，甚至不如多线程模型的 BIO ，这就对开发者的技术有更高的要求了。<br>另一方面，基于事件驱动的 I/O 多路复用，仍然属于阻塞型 I/O，它会阻塞在等待事件发生的系统调用。<br>I/O 多路复用案例</p>
<p>I/O 多路复用技术，已经在很多高性能软件和系统中得到广泛使用，只要弄明白了 I/O 多路复用的底层原理，也就明白那些优秀的软件为何性能很高了。经典的如 Redis，我们知道 Redis 是一个高性能的缓存服务器，它是单线程的，但它的性能并没有因为单线程而降低，反而特别高效，其中一个很重要的原因就是使用的 I/O 多路复用。在 Redis 内部，将客户端的套接字以文件事件进行抽象，客户端的连接，读写等操作，均会在 Redis 产生相应的文件事件，然后由相应的事件处理器进行处理，而 Redis 的单线程，可以监听成千上万个套接字，从而保证了高效的网络通信。同时，Redis 有良好的跨平台特性，由此我们可以断定，Redis 底层并没有写死使用 epoll 方式，因为那样会限制它只能运行于 Linux 平台，实际上，在我们编译 Redis 时，Redis 会根据平台情况，选择使用最合适的方式。<br>再如 Nginx，Nginx 是一款优秀的，抗并发能力很强的 web 服务器，在它的 Worker 进程中，也是通过 kqueue、epoll 等事件通知机制循环处理连接请求，可以使 Nginx 在高并发的情况下，仍然保持较低的 CPU 使用率，同时它也有良好的跨平台特性。nginx 的架构模型可以参考这篇文章<br>再如 Netty，Netty 是 Java 写的高性能网络编程框架，它是 Java NIO 库的进一步封装，大大简化了 NIO 的使用方式，Netty 的网络部分使用了经典的 Reactor 模式，其中的 IO 线程 NioEventLoop 聚合了多路复用器，称为 Selector，根据平台选择不同的 I/O 多路复用，如 kqueue、epoll。同时，它可以搭配线程池使用，每个线程都是一个 Selector，成为多线程的 Reactor 模型。因此它的性能也非常强劲。Netty 的线程模型可以看这篇文章<br>总结</p>
<p>上面，我们讨论了传统的 BIO 模式的弊端，以及 I/O 多路复用的原理和经典使用案例，那么我们以后写网络程序，是不是无脑用 I/O 多路复用呢？得看场景：<br>如果你的应用并发量不大，用户的请求连接少，连接不是瓶颈，那么请直接使用 BIO+多线程方式，简单易调试，完全用不着 I/O 多路复用，这样只会增加代码的复杂度，出问题难以调试。<br>如果你的应用并发量高，需要同时处理海量的连接，那么请使用 I/O 多路复用方式。但是记住，你必须始终保持异步思想，事件处理中不要有任何阻塞操作。至于是用 select/poll 还是 epoll，请看这篇文章<br>参考<br><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a><br><a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll" target="_blank" rel="noopener">https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</a><br><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</a><br><a href="https://www.zhihu.com/question/20122137" target="_blank" rel="noopener">https://www.zhihu.com/question/20122137</a><br><a href="http://kimi.it/515.html" target="_blank" rel="noopener">http://kimi.it/515.html</a><br><a href="https://segmentfault.com/a/1190000016875057" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016875057</a></p>
<p>本文由 JimmyXu 发表，采用署名-非商业性使用-禁止演绎4.0进行许可<br>非商业转载请注明作者及出处，商业转载请联系作者本人<br>本文标题: 什么是 I/O 多路复用<br>本文链接: <a href="http://xujimmy.com/2019/06/27/what-is-io-multiplexing.html" target="_blank" rel="noopener">http://xujimmy.com/2019/06/27/what-is-io-multiplexing.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2018/01/21/2018/linux-elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/2018/linux-elasticsearch/" itemprop="url">Linux环境部署Elasticsearch 6.x和常见问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-21T21:13:02+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES/" itemprop="url" rel="index">
                    <span itemprop="name">ES</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Elasticsearch（ES）是一个基于Lucene构建的开源、分布式、RESTful接口的全文搜索引擎。 Elasticsearch还是一个分布式文档数据库，其中每个字段均可被索引，而且每个字段的数据均可被搜索，ES能够横向扩展至数以百计的服务器存储以及处理PB级的数据。</p>
<p>本文内容基于Elastic 技术栈6.x版本；</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># lasticsearch-6-3-2</span><br><span class="line"></span><br><span class="line">wget https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-3-2</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.2.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载到指定目录~/path/，解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-6.3.2.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>由于elasticsearch 不允许使用root用户启动<br>创建一个用于启动elasticsearch 的用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd  elastic </span><br><span class="line">passwd  elastic</span><br></pre></td></tr></table></figure></p>
<p>输入密码，并确认，完成特定用户创建</p>
<p>并为该用户授权elasticsearch相关目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R elastic:elastic elasticsearch*</span><br></pre></td></tr></table></figure></p>
<p>切换到用户elastic ，创建elasticsearch目录软连接指向elastic用户的根目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">ln -s /path/to/elasticsearch ./elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>进入该目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>启动elasticsearch</p>
<p>后台启动 (daemonize)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch  -d</span><br></pre></td></tr></table></figure></p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>启动错误提示1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ERROR: [4] bootstrap checks failed</span><br><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br><span class="line">[2]: max number of threads [1024] for user [elastic] is too low, increase to at least [4096]</span><br><span class="line">[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line">[4]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br><span class="line"></span><br><span class="line">Make sure to increase the limit on the number of open files descriptors for the user running Elasticsearch to 65,536 or higher. For the .zip and .tar.gz packages, set ulimit -n 65536 as root before starting Elasticsearch, or set nofile to 65536 in /etc/security/limits.conf .</span><br></pre></td></tr></table></figure>
<p>解决：切换到root用户，编辑limits.conf 添加相关配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br></pre></td></tr></table></figure></p>
<p>添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure></p>
<p>启动错误提示2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2]: max number of threads [1024] for user [elastic] is too low, increase to at least [4096]</span><br></pre></td></tr></table></figure></p>
<p>对于第二条错误同意需要切换到root用户，进入limits.d目录下修改配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.d/90-nproc.conf</span><br></pre></td></tr></table></figure></p>
<p>修改如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 1024</span><br></pre></td></tr></table></figure></p>
<p>#修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft nproc 4096</span><br></pre></td></tr></table></figure></p>
<p>错误提示3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br></pre></td></tr></table></figure></p>
<p>第三条错误需要切换到root用户修改配置sysctl.conf<br>vi /etc/sysctl.conf </p>
<p>添加下面配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></p>
<p>并执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<p>错误提示4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</span><br></pre></td></tr></table></figure></p>
<p>原因：<br>这是在因为Centos6不支持SecComp，而ES 6.x默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。</p>
<p>解决：<br>在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></p>
<p>操作完成，现在所有的机器都能访问Linux服务器的HTTP服务了。</p>
<p>监控健康状况<br>http://[es_host]:9200/_cat/health?v<br>监控节点情况<br>http://[es_host]:9200/_cat/nodes?v<br>监控索引情况<br>http://[es_host]:9200/_cat/indices?v</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2016/05/01/4-redis-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/01/4-redis-1/" itemprop="url">Redis系列之应用范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-01T00:16:29+08:00">
                2016-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoSQL/" itemprop="url" rel="index">
                    <span itemprop="name">NoSQL</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoSQL/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis 是互联网技术领域使用最为广泛的存储中间件，它是「Remote Dictionary Service」的首字母缩写，也就是「远程字典服务」。Redis 以其超高的性能、完美的文档、简洁易懂的源码和丰富的客户端库支持在开源中间件领域广受好评。</p>
<p>例如:<br>1.记录帖子的点赞数、评论数和点击数 (hash)。<br>2.记录用户的帖子 ID 列表 (排序)，便于快速显示用户的帖子列表 (zset)。<br>3.记录帖子的标题、摘要、作者和封面信息，用于列表页展示 (hash)。<br>4.记录帖子的点赞用户 ID 列表，评论 ID 列表，用于显示和去重计数 (zset)。<br>5.缓存近期热帖内容 (帖子内容空间占用比较大)，减少数据库压力 (hash)。<br>6.记录帖子的相关文章 ID，根据内容推荐相关帖子 (list)。<br>7.如果帖子 ID 是整数自增的，可以使用 Redis 来分配帖子 ID(计数器)。<br>8.收藏集和帖子之间的关系 (zset)。<br>9.记录热榜帖子 ID 列表，总热榜和分类热榜 (zset)。<br>10.缓存用户行为历史，进行恶意行为过滤 (zset,hash)。</p>
<p>当然，实际情况下需求可能也没这么多，因为在请求压力不大的情况下，很多数据都是可以直接从数据库中查询的。但请求压力一大，以前通过数据库直接存取的数据则必须要挪到缓存里来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2015/03/21/mysql-master-slave/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/21/mysql-master-slave/" itemprop="url">基于Mysql binglog的主从同步搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-03-21T23:13:02+08:00">
                2015-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是MySQL主从复制"><a href="#什么是MySQL主从复制" class="headerlink" title="什么是MySQL主从复制"></a>什么是MySQL主从复制</h2><p>简单来说就是保证主SQL（Master）和从SQL（Slave）的数据是一致性的，向Master插入数据后，Slave会自动从Master把修改的数据同步过来（有一定的延迟），通过这种方式来保证数据的一致性，就是主从复制</p>
<h2 id="MySQL主从能解决什么问题"><a href="#MySQL主从能解决什么问题" class="headerlink" title="MySQL主从能解决什么问题"></a>MySQL主从能解决什么问题</h2><h3 id="一、高可用"><a href="#一、高可用" class="headerlink" title="一、高可用"></a>一、高可用</h3><p>因为数据都是相同的，所以当Master挂掉后，可以指定一台Slave充当Master继续保证服务运行，因为数据是一致性的（如果当插入Master就挂掉，可能不一致，因为同步也需要时间），当然这种配置不是简单的把一台Slave充当Master，毕竟还要考虑后续的Salve同步Master，当然本文并不是将高可用的配置，所以这里就不多讲了</p>
<h3 id="二、负载均衡"><a href="#二、负载均衡" class="headerlink" title="二、负载均衡"></a>二、负载均衡</h3><p>因为读写分离也算是负载均衡的一种，所以就不单独写了，因为一般都是有多台Slave的，所以可以将读操作指定到Slave服务器上（需要代码控制），然后再用负载均衡来选择那台Slave来提供服务，同时也可以吧一些大量计算的查询指定到某台Slave，这样就不会影响Master的写入以及其他查询</p>
<h3 id="三、数据备份"><a href="#三、数据备份" class="headerlink" title="三、数据备份"></a>三、数据备份</h3><p>一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全</p>
<h3 id="四、业务模块化"><a href="#四、业务模块化" class="headerlink" title="四、业务模块化"></a>四、业务模块化</h3><p>可以一个业务模块读取一个Slave，再针对不同的业务场景进行数据库的索引创建和根据业务选择MySQL存储引擎</p>
<h3 id="五、高扩展（硬件扩展）"><a href="#五、高扩展（硬件扩展）" class="headerlink" title="五、高扩展（硬件扩展）"></a>五、高扩展（硬件扩展）</h3><p>主从复制支持2种扩展方式</p>
<h4 id="1、scale-up"><a href="#1、scale-up" class="headerlink" title="1、scale-up"></a>1、scale-up</h4><p>向上扩展或者纵向扩展，主要是提供比现在服务器更好性能的服务器，比如增加CPU和内存以及磁盘阵列等，因为有多台服务器，所以可扩展性比单台更大</p>
<h4 id="2、scale-out"><a href="#2、scale-out" class="headerlink" title="2、scale-out"></a>2、scale-out</h4><p>向外扩展或者横向扩展，是指增加服务器数量的扩展，这样主要能分散各个服务器的压力</p>
<h2 id="主从复制的缺点"><a href="#主从复制的缺点" class="headerlink" title="主从复制的缺点"></a>主从复制的缺点</h2><h3 id="一、成本增加"><a href="#一、成本增加" class="headerlink" title="一、成本增加"></a>一、成本增加</h3><p>无可厚非的是搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启二进制日志，所以也会造成额外的性能消耗</p>
<h3 id="二、数据延迟"><a href="#二、数据延迟" class="headerlink" title="二、数据延迟"></a>二、数据延迟</h3><p>Slave从Master复制过来肯定是会有一定的数据延迟的，所以当刚插入就出现查询的情况，可能查询不出来，当然如果是插入者自己查询，那么可以直接从Master中查询出来，当然这个也是需要用代码来控制的</p>
<h3 id="三、写入更慢"><a href="#三、写入更慢" class="headerlink" title="三、写入更慢"></a>三、写入更慢</h3><p>主从复制主要是针对读远大于写或者对数据备份实时性要求较高的系统中，因为Master在写中需要更多操作，而且只有一台写入的Master（因为我目前只会配置一台写入Master，最多就是有从Master的Slave，用来在Master挂掉后替换成Master，平时不对外进行服务），所以写入的压力并不能被分散，当然如果直接怎么解决这个问题的话，欢迎留言指教</p>
<h2 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a>复制方式</h2><p>MySQL5.6开始主从复制有两种方式：基于日志（binlog）、基于GTID（全局事务标示符）。<br>本文只涉及基于日志binlog的主从配置</p>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>1、Master将数据改变记录到二进制日志(binary log)中，也就是配置文件log-bin指定的文件，这些记录叫做二进制日志事件(binary log events)<br>2、Slave通过I/O线程读取Master中的binary log events并写入到它的中继日志(relay log)<br>3、Slave重做中继日志中的事件，把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储，从而实现将改变反映到它自己的数据(数据重放)</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>1、主从服务器操作系统版本和位数一致<br>2、Master和Slave数据库的版本要一致<br>3、Master和Slave数据库中的数据要一致<br>4、Master开启二进制日志，Master和Slave的server_id在局域网内必须唯一</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><h3 id="硬件需求"><a href="#硬件需求" class="headerlink" title="硬件需求"></a>硬件需求</h3><p>两台或两台以上安装了相同版本的MySQL（我没有试过不同版本会不会有问题，有兴趣的可以试试），当然这个可以用虚拟机或者Docker代替，个人推荐用Docker，比虚拟机消耗少太多了，当然用起来可能没有虚拟机那么方便，但是却不用挨个环境配置了</p>
<h3 id="配置Master"><a href="#配置Master" class="headerlink" title="配置Master"></a>配置Master</h3><h4 id="一、安装数据库"><a href="#一、安装数据库" class="headerlink" title="一、安装数据库"></a>一、安装数据库</h4><h4 id="二、配置my-cnf"><a href="#二、配置my-cnf" class="headerlink" title="二、配置my.cnf"></a>二、配置my.cnf</h4><p>不同的系统my.cnf路径不同，所以我们只讲解牵扯修改的地方。添加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP,注意要唯一</span><br><span class="line">server_id=100  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span><br><span class="line">log-bin=edu-mysql-bin  </span><br><span class="line">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure>
<h4 id="配置完成后重启mysql"><a href="#配置完成后重启mysql" class="headerlink" title="配置完成后重启mysql"></a>配置完成后重启mysql</h4><h3 id="关于复制过滤"><a href="#关于复制过滤" class="headerlink" title="关于复制过滤"></a>关于复制过滤</h3><h4 id="复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤："><a href="#复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤：" class="headerlink" title="复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤："></a>复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤：</h4><p>1、在Master上过滤二进制日志中的事件<br>2、在Slave上过滤中继日志中的事件。</p>
<h4 id="复制类型"><a href="#复制类型" class="headerlink" title="复制类型"></a>复制类型</h4><h4 id="1、基于语句的复制"><a href="#1、基于语句的复制" class="headerlink" title="1、基于语句的复制"></a>1、基于语句的复制</h4><p>在Master上执行的SQL语句，在Slave上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。一旦发现没法精确复制时，会自动选着基于行的复制</p>
<h4 id="2、基于行的复制"><a href="#2、基于行的复制" class="headerlink" title="2、基于行的复制"></a>2、基于行的复制</h4><p>把改变的内容复制到Slave，而不是把命令在Slave上执行一遍。从MySQL5.0开始支持</p>
<h4 id="3、混合类型的复制"><a href="#3、混合类型的复制" class="headerlink" title="3、混合类型的复制"></a>3、混合类型的复制</h4><p>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制</p>
<h3 id="三、创建数据同步用户"><a href="#三、创建数据同步用户" class="headerlink" title="三、创建数据同步用户"></a>三、创建数据同步用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class="line"></span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure>
<p>这里主要是要授予用户REPLICATION SLAVE权限和REPLICATION CLIENT权限</p>
<h3 id="配置Slave"><a href="#配置Slave" class="headerlink" title="配置Slave"></a>配置Slave</h3><h4 id="一、安装数据库-1"><a href="#一、安装数据库-1" class="headerlink" title="一、安装数据库"></a>一、安装数据库</h4><h4 id="二、配置my-cnf-1"><a href="#二、配置my-cnf-1" class="headerlink" title="二、配置my.cnf"></a>二、配置my.cnf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP,注意要唯一</span><br><span class="line">server_id=101  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin=edu-mysql-slave1-bin  </span><br><span class="line">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=edu-mysql-relay-bin  </span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1  </span><br><span class="line">## 防止改变数据(除了特殊的线程)</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>
<p>如果Slave为其它Slave的Master时，必须设置bin_log。配置完成后重启mysql</p>
<h4 id="完成Master和Slave链接"><a href="#完成Master和Slave链接" class="headerlink" title="完成Master和Slave链接"></a>完成Master和Slave链接</h4><h4 id="一、初始化数据"><a href="#一、初始化数据" class="headerlink" title="一、初始化数据"></a>一、初始化数据</h4><p>保证Master和Slave除不同步的数据库，其他库的数据一致</p>
<h4 id="二、查询Master状态"><a href="#二、查询Master状态" class="headerlink" title="二、查询Master状态"></a>二、查询Master状态</h4><p>在Master中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure></p>
<p>记录下返回结果的File列和Position列的值</p>
<h4 id="三、Slave中设置Master信息"><a href="#三、Slave中设置Master信息" class="headerlink" title="三、Slave中设置Master信息"></a>三、Slave中设置Master信息</h4><p>在Slave中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.1.100&apos;, master_user=&apos;slave&apos;, master_password=&apos;123456&apos;, master_port=3306, master_log_file=&apos;edu-mysql-bin.000001&apos;, master_log_pos=1389, master_connect_retry=30;</span><br></pre></td></tr></table></figure></p>
<p>上面执行的命令的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">master_host=&apos;192.168.1.100&apos; ## Master的IP地址</span><br><span class="line"></span><br><span class="line">master_user=&apos;slave&apos; ## 用于同步数据的用户（在Master中授权的用户）</span><br><span class="line"></span><br><span class="line">master_password=&apos;123456&apos; ## 同步数据用户的密码</span><br><span class="line"></span><br><span class="line">master_port=3306 ## Master数据库服务的端口</span><br><span class="line"></span><br><span class="line">masterlogfile=&apos;edu-mysql-bin.000001&apos; ##指定Slave从哪个日志文件开始读复制数据（Master上执行命令的结果的File字段）</span><br><span class="line"></span><br><span class="line">masterlogpos=429 ## 从哪个POSITION号开始读（Master上执行命令的结果的Position字段）</span><br><span class="line"></span><br><span class="line">masterconnectretry=30 ##当重新建立主从连接时，如果连接建立失败，间隔多久后重试。单位为秒，默认设置为60秒，同步延迟调优参数。</span><br></pre></td></tr></table></figure></p>
<h4 id="四、查看主从同步状态"><a href="#四、查看主从同步状态" class="headerlink" title="四、查看主从同步状态"></a>四、查看主从同步状态</h4><h4 id="在Slave中执行命令"><a href="#在Slave中执行命令" class="headerlink" title="在Slave中执行命令"></a>在Slave中执行命令</h4><p>show slave status;<br>可看到SlaveIOState为空， SlaveIORunning和SlaveSQLRunning是No，表明Slave还没有开始复制过程。相反SlaveIORunning和SlaveSQLRunning是Yes表明已经开始工作了</p>
<h4 id="五、开启主从同步"><a href="#五、开启主从同步" class="headerlink" title="五、开启主从同步"></a>五、开启主从同步</h4><h4 id="在Slave中执行命令-1"><a href="#在Slave中执行命令-1" class="headerlink" title="在Slave中执行命令"></a>在Slave中执行命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>
<p>查询查看主从同步状态，会发现SlaveIORunning和SlaveSQLRunning是Yes了，表明开启成功</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2015/02/21/mysql-remove-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/21/mysql-remove-data/" itemprop="url">基于Mysql特性对删除大表数据的一些建议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-02-21T20:13:02+08:00">
                2015-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>生产环境，往往需要更新/删除大量的数据，由于很可能消耗太多的IO资源，对于生产繁忙的系统，需要小心，以避免对生产环境造成影响。<br>删除大量数据还有一些副作用，比如主从延时、数据文件无法收缩、锁表等。<br>以下是一些要指引和规则：<br>1、批量删除，这样往往可以工作得更快，你可能需要在每次批量删除前sleep一段时间，控制删除的频率，这样的目的是减少对生产系统的IO冲击，把符合平均分布，避免从库滞后太多；<br>2、可以考虑分区表技术，我很少用分区表，但删除一个分区，显然比删除大量数据简单方便的多，这也是分区表清理/归档数据的优势所在；<br>3、按照主键的序列分批分批，或者基于时间分批分批，你总可以找到一种方式批量删除，如果实在没有批量删除的方式，可能你的表结构设计得不好；<br>4、基于硬件的性能，每批删除的记录数，可以选择几百到几千到几万的数据量，但不要太大，MySQL很难同时处理好大事务和随机小事务；<br>5、如果要删除大部分数据，那么可以考虑的方式是，创建一个新表，insert要保留的数据，然后切换表；<br>6、对于大表(InnoDB)删除大量数据，如果是一个很大的事务，中止删除数据的操作，可能需要几倍的时间用于回滚，导致严重的IO瓶颈，而批量删除可以让我们的回滚恢复得快得多。<br>7、需要留意空间的释放，选择独立表空间会更有利于释放空间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2013/02/10/3-custom-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2013/02/10/3-custom-cache/" itemprop="url">Java实现简单的缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-02-10T00:13:48+08:00">
                2013-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="通过map模拟缓存实现"><a href="#通过map模拟缓存实现" class="headerlink" title="通过map模拟缓存实现"></a>通过map模拟缓存实现</h4><h5 id="1-定义缓存包装类"><a href="#1-定义缓存包装类" class="headerlink" title="1.定义缓存包装类"></a>1.定义缓存包装类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Cache &#123;</span><br><span class="line">        private String key;//缓存ID</span><br><span class="line">        private Object value;//缓存数据</span><br><span class="line">        private long timeOut;//更新时间</span><br><span class="line">        private boolean expired; //是否终止</span><br><span class="line">        public Cache() &#123;</span><br><span class="line">                super();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Cache(String key, Object value, long timeOut, boolean expired) &#123;</span><br><span class="line">                this.key = key;</span><br><span class="line">                this.value = value;</span><br><span class="line">                this.timeOut = timeOut;</span><br><span class="line">                this.expired = expired;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getKey() &#123;</span><br><span class="line">                return key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public long getTimeOut() &#123;</span><br><span class="line">                return timeOut;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object getValue() &#123;</span><br><span class="line">                return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setKey(String string) &#123;</span><br><span class="line">                key = string;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setTimeOut(long l) &#123;</span><br><span class="line">                timeOut = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setValue(Object object) &#123;</span><br><span class="line">                value = object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean isExpired() &#123;</span><br><span class="line">                return expired;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setExpired(boolean b) &#123;</span><br><span class="line">                expired = b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-定义缓存工具类"><a href="#2-定义缓存工具类" class="headerlink" title="2.定义缓存工具类"></a>2.定义缓存工具类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">public class CacheManager &#123;</span><br><span class="line">    private static HashMap cacheMap = new HashMap();</span><br><span class="line"></span><br><span class="line">    //单实例构造方法</span><br><span class="line">    private CacheManager() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    //获取布尔值的缓存</span><br><span class="line">    public static boolean getSimpleFlag(String key)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            return (Boolean) cacheMap.get(key);</span><br><span class="line">        &#125;catch(NullPointerException e)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static long getServerStartdt(String key)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Long)cacheMap.get(key);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置布尔值的缓存</span><br><span class="line">    public synchronized static boolean setSimpleFlag(String key,boolean flag)&#123;</span><br><span class="line">        if (flag &amp;&amp; getSimpleFlag(key)) &#123;//假如为真不允许被覆盖</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cacheMap.put(key, flag);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static boolean setSimpleFlag(String key,long serverbegrundt)&#123;</span><br><span class="line">        if (cacheMap.get(key) == null) &#123;</span><br><span class="line">            cacheMap.put(key,serverbegrundt);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //得到缓存。同步静态方法</span><br><span class="line">    private synchronized static Cache getCache(String key) &#123;</span><br><span class="line">        return (Cache) cacheMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否存在一个缓存</span><br><span class="line">    private synchronized static boolean hasCache(String key) &#123;</span><br><span class="line">        return cacheMap.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清除所有缓存</span><br><span class="line">    public synchronized static void clearAll() &#123;</span><br><span class="line">        cacheMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清除某一类特定缓存,通过遍历HASHMAP下的所有对象，来判断它的KEY与传入的TYPE是否匹配</span><br><span class="line">    public synchronized static void clearAll(String type) &#123;</span><br><span class="line">        Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">        String key;</span><br><span class="line">        ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                key = (String) entry.getKey();</span><br><span class="line">                if (key.startsWith(type)) &#123; //如果匹配则删除掉</span><br><span class="line">                    arr.add(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int k = 0; k &lt; arr.size(); k++) &#123;</span><br><span class="line">                clearOnly(arr.get(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清除指定的缓存</span><br><span class="line">    public synchronized static void clearOnly(String key) &#123;</span><br><span class="line">        cacheMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //载入缓存</span><br><span class="line">    public synchronized static void putCache(String key, Cache obj) &#123;</span><br><span class="line">        cacheMap.put(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存信息</span><br><span class="line">    public static Cache getCacheInfo(String key) &#123;</span><br><span class="line"></span><br><span class="line">        if (hasCache(key)) &#123;</span><br><span class="line">            Cache cache = getCache(key);</span><br><span class="line">            if (cacheExpired(cache)) &#123; //调用判断是否终止方法</span><br><span class="line">                cache.setExpired(true);</span><br><span class="line">            &#125;</span><br><span class="line">            return cache;</span><br><span class="line">        &#125;else</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //载入缓存信息</span><br><span class="line">    public static void putCacheInfo(String key, Cache obj, long dt,boolean expired) &#123;</span><br><span class="line">        Cache cache = new Cache();</span><br><span class="line">        cache.setKey(key);</span><br><span class="line">        cache.setTimeOut(dt + System.currentTimeMillis()); //设置多久后更新缓存</span><br><span class="line">        cache.setValue(obj);</span><br><span class="line">        cache.setExpired(expired); //缓存默认载入时，终止状态为FALSE</span><br><span class="line">        cacheMap.put(key, cache);</span><br><span class="line">    &#125;</span><br><span class="line">    //重写载入缓存信息方法</span><br><span class="line">    public static void putCacheInfo(String key,Cache obj,long dt)&#123;</span><br><span class="line">        Cache cache = new Cache();</span><br><span class="line">        cache.setKey(key);</span><br><span class="line">        cache.setTimeOut(dt+System.currentTimeMillis());</span><br><span class="line">        cache.setValue(obj);</span><br><span class="line">        cache.setExpired(false);</span><br><span class="line">        cacheMap.put(key,cache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断缓存是否终止</span><br><span class="line">    public static boolean cacheExpired(Cache cache) &#123;</span><br><span class="line">        if (null == cache) &#123; //传入的缓存不存在</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        long nowDt = System.currentTimeMillis(); //系统当前的毫秒数</span><br><span class="line">        long cacheDt = cache.getTimeOut(); //缓存内的过期毫秒数</span><br><span class="line">        if (cacheDt &lt;= 0||cacheDt&gt;nowDt) &#123; //过期时间小于等于零时,或者过期时间大于当前时间时，则为FALSE</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123; //大于过期时间 即过期</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存中的大小</span><br><span class="line">    public static int getCacheSize() &#123;</span><br><span class="line">        return cacheMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取指定的类型的大小</span><br><span class="line">    public static int getCacheSize(String type) &#123;</span><br><span class="line">        int k = 0;</span><br><span class="line">        Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">        String key;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                key = (String) entry.getKey();</span><br><span class="line">                if (key.indexOf(type) != -1) &#123; //如果匹配则删除掉</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存对象中的所有键值名称</span><br><span class="line">    public static ArrayList&lt;String&gt; getCacheAllkey() &#123;</span><br><span class="line">        ArrayList a = new ArrayList();</span><br><span class="line">        try &#123;</span><br><span class="line">            Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                a.add((String) entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;&#125; finally &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取缓存对象中指定类型 的键值名称</span><br><span class="line">    public static ArrayList&lt;String&gt; getCacheListkey(String type) &#123;</span><br><span class="line">        ArrayList a = new ArrayList();</span><br><span class="line">        String key;</span><br><span class="line">        try &#123;</span><br><span class="line">            Iterator i = cacheMap.entrySet().iterator();</span><br><span class="line">            while (i.hasNext()) &#123;</span><br><span class="line">                java.util.Map.Entry entry = (java.util.Map.Entry) i.next();</span><br><span class="line">                key = (String) entry.getKey();</span><br><span class="line">                if (key.indexOf(type) != -1) &#123;</span><br><span class="line">                    a.add(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception ex) &#123;&#125; finally &#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-缓存测试类"><a href="#3-缓存测试类" class="headerlink" title="3.缓存测试类"></a>3.缓存测试类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(CacheManager.getSimpleFlag(&quot;alksd&quot;));</span><br><span class="line">//        CacheManager.putCache(&quot;foot ball&quot;, new Cache());</span><br><span class="line">//        CacheManager.putCache(&quot;basket ball&quot;, new Cache());</span><br><span class="line">//        CacheManager.putCache(&quot;apple&quot;, new Cache());</span><br><span class="line">//        CacheManager.clearOnly(&quot;&quot;);</span><br><span class="line">//        Cache c = new Cache();</span><br><span class="line">//        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">//            CacheManager.putCache(&quot;&quot; + i, c);</span><br><span class="line">//        &#125;</span><br><span class="line">//        CacheManager.putCache(&quot;key1&quot;, c);</span><br><span class="line">//        CacheManager.putCache(&quot;key2&quot;, c);</span><br><span class="line">//        CacheManager.putCache(&quot;key3&quot;, c);</span><br><span class="line">//        System.out.println(&quot;清除前的大小：&quot;+CacheManager.getCacheSize());</span><br><span class="line">//        CacheManager.getCacheAllkey();</span><br><span class="line">//        CacheManager.clearAll(&quot;aaaa&quot;);</span><br><span class="line">//        System.out.println(&quot;清除后的大小：&quot;+CacheManager.getCacheSize());</span><br><span class="line">//        CacheManager.getCacheAllkey();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changwei0708.github.io/2013/01/01/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luchangwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fz00x0zf's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2013/01/01/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-01-01T00:00:00+08:00">
                2013-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">luchangwei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luchangwei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
